<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Periodic Delaunay-Voronoi - Three.js Visualization</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/",
            "poisson-disk-sampling": "https://esm.sh/poisson-disk-sampling@2.3.0"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 380px;
        }
        #controls-content { max-height: calc(100vh - 40px); overflow-y: auto; }
        .control-group {
            margin: 10px 0;
        }
        .section-header { font-weight: bold; margin: 12px 0 6px 0; padding: 6px 8px; background: #f2f2f2; border-radius: 4px; }
        #controls-toggle { background: #007bff; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-bottom: 8px; }
        #controls.hidden { width: auto; padding: 8px 10px; }
        #controls.hidden #controls-content { display: none; }
        .row-2 { display: grid; grid-template-columns: auto 1fr; gap: 8px 16px; align-items: center; }
        .row-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; align-items: center; }
        .row-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; align-items: center; }
        .sub-label { font-size: 12px; text-align: center; opacity: 0.85; }
        .inline-pair { display: flex; align-items: center; gap: 8px; }
        .inline-tight { gap: 4px; }
        label {
            display: inline-block;
            width: 100px;
            font-size: 14px;
            white-space: nowrap;
        }
        input[type="number"] {
            width: 80px;
        }
        button {
            margin: 5px 0;
            padding: 5px 10px;
            width: 100%;
        }
        .status { 
            font-size: 12px; 
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-group label {
            width: 80px; /* Adjust as needed */
            font-size: 14px;
            white-space: nowrap;
        }
        .slider-group input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            height: 8px;
            background: #d3d3d3;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider-group input[type="range"]:hover {
            opacity: 1;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #007bff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 2px #000000;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #007bff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 2px #000000;
        }
        .slider-group input[type="number"] {
            width: 80px;
            text-align: center;
        }
        /* Legend panel */
        .legend-panel { margin-top: 8px; padding: 8px; background: #f5f5f5; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .legend-title { font-weight: 700; margin-bottom: 6px; }
        .legend-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin: 4px 0; }
        .legend-left { display: flex; align-items: center; gap: 8px; }
        .legend-swatch { width: 18px; height: 12px; border: 1px solid #999; border-radius: 3px; display: inline-block; }
        .legend-range { font-size: 13px; }
        .legend-count { font-size: 12px; opacity: 0.75; }
        .legend-footer { margin-top: 6px; font-size: 12px; opacity: 0.85; }
    </style>
</head>
<body>
    
    <div id="controls" class="controls-container">
        <button id="controls-toggle" title="Hide Controls">hide</button>
        <div id="controls-content">
        <div class="section-header">Voro-X / Geogram</div>
        <div class="control-group row-2">
            <div class="inline-pair"><label>Points:</label><input type="number" id="numPoints" value="150" min="4" max="5000"></div>
            <div class="inline-pair inline-tight"><label>Min Dist:</label><input style="margin-left:-6px" type="number" id="minDistance" value="0.05" min="0.001" max="0.3" step="0.001"></div>
        </div>
        <div class="control-group row-2">
             <button id="regenerate">Generate</button>
             <button id="recompute">Recompute</button>
        </div>
        <div class="control-group">
            <label>Voronoi Method:</label>
            <select id="voronoiMethod">
                <option value="barycenter" selected>Barycenter</option>
                <option value="circumcenter">Circumcenter</option>
            </select>
        </div>
        <div class="control-group row-3">
            <div class="sub-label">Periodic</div>
            <div class="sub-label">Ghost Cells</div>
            <div class="sub-label">MIC</div>
            <div style="text-align:center"><input type="checkbox" id="periodicMode"></div>
            <div style="text-align:center"><input type="checkbox" id="showGhostCells"></div>
            <div style="text-align:center"><input type="checkbox" id="useMIC"></div>
        </div>
        <div class="control-group row-3">
            <div class="sub-label">Background</div>
            <div class="sub-label">Boundary</div>
            <div class="sub-label">Poisson</div>
            <div style="text-align:center"><input type="color" id="backgroundColor" value="#f0f0f0"></div>
            <div style="text-align:center"><input type="checkbox" id="showBoundary" checked></div>
            <div style="text-align:center"><input type="checkbox" id="poissonSampling" checked></div>
        </div>
        <hr>
        <div class="section-header">Flow Dynamics - Core Physics</div>
        <div class="control-group">
            <div class="row-3">
                <button id="resampleBtn">Resample</button>
                <button id="stepBtn">Step</button>
                <button id="runBtn">Run</button>
            </div>
        </div>
        <!-- Basic Physics Parameters -->
        <div class="control-group slider-group" title="Time step for physics integration">
            <label for="dynDt">dt (Time Step)</label>
            <input type="range" id="dynDt" min="0.001" max="0.1" step="0.001" value="0.02">
            <input type="number" id="dynDtNum" min="0.001" max="0.1" step="0.001" value="0.02">
        </div>
        <div class="control-group slider-group" title="Force multiplier for all dynamics">
            <label for="dynEnergy">Energy</label>
            <input type="range" id="dynEnergy" min="0.00001" max="0.001" step="0.00001" value="0.0005">
            <input type="number" id="dynEnergyNum" min="0.00001" max="0.001" step="0.00001" value="0.0005">
        </div>
        <div class="control-group slider-group" title="Target edge length for equilibration">
            <label for="dynScale">Scale</label>
            <input type="range" id="dynScale" min="0.1" max="2.0" step="0.05" value="0.5">
            <input type="number" id="dynScaleNum" min="0.1" max="2.0" step="0.05" value="0.5">
        </div>
        <div class="control-group row-2">
            <div class="inline-pair" title="Apply forces to edges vs centers"><input type="checkbox" id="dynEdgeScale" checked><label>Edge Scale</label></div>
            <div class="inline-pair" title="Enable basic equilibration forces"><input type="checkbox" id="dynEquilibration" checked><label>Equilibration</label></div>
        </div>
        
        <!-- PageRank System Controls -->
        <div class="section-header">Edge PageRank System</div>
        <div class="control-group row-2">
            <div class="inline-pair" title="Use edge-based PageRank instead of tetrahedra"><input type="checkbox" id="dynUseEdgeMode"><label>Edge PageRank</label></div>
            <div class="inline-pair" title="Use Verlet integration for stability"><input type="checkbox" id="dynUseVerlet"><label>Verlet Integration</label></div>
        </div>
        <div class="control-group slider-group" title="PageRank iterations (higher = more accurate)">
            <label for="dynSearchDepth">Search Depth</label>
            <input type="range" id="dynSearchDepth" min="5" max="30" step="1" value="15">
            <input type="number" id="dynSearchDepthNum" min="5" max="30" step="1" value="15">
        </div>
        <div class="control-group slider-group" title="Score threshold for contractive/expansive forces">
            <label for="dynThreshold">Threshold</label>
            <input type="range" id="dynThreshold" min="0" max="1" step="0.01" value="0.5">
            <input type="number" id="dynThresholdNum" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="control-group row-2">
            <div class="inline-pair" title="Contract faces with score < threshold"><input type="checkbox" id="dynContractive"><label>Contractive</label></div>
            <div class="inline-pair" title="Expand faces with score > threshold"><input type="checkbox" id="dynExpansive"><label>Expansive</label></div>
        </div>
        <div class="control-group slider-group" title="Velocity damping for Verlet integration">
            <label for="dynDamping">Damping</label>
            <input type="range" id="dynDamping" min="0.8" max="1.0" step="0.01" value="0.99">
            <input type="number" id="dynDampingNum" min="0.8" max="1.0" step="0.01" value="0.99">
        </div>

        <!-- Two-Phase Cadence + XPBD Guard -->
        <div class="section-header">Two-Phase Cadence + XPBD</div>
        <div class="control-group row-2" title="Physical steps between Brain recomputes">
            <label for="physPerBrain">Physics per Brain</label>
            <input type="number" id="physPerBrain" min="1" max="50" step="1" value="10">
        </div>
        <div class="control-group row-2" title="Retriangulate every N Physical steps (testing)">
            <label for="retriEvery">Retriangulate every</label>
            <input type="number" id="retriEvery" min="1" max="10000" step="1" value="999">
        </div>
        <div class="control-group row-2" title="Max per-face scale change per Physical step (XPBD)">
            <label for="xpbdMaxScale">Max face scale/step</label>
            <input type="number" id="xpbdMaxScale" min="0" max="0.5" step="0.01" value="0.10">
        </div>
        <div class="control-group row-2" title="Strength g: scales per-face percentage change">
            <label for="xpbdStrength">Strength (g)</label>
            <input type="number" id="xpbdStrength" min="0" max="1" step="0.001" value="0.001">
        </div>
        <div class="control-group row-2" title="Shaping exponent Î³: curve response vs |sâˆ’t| (1.0 = linear)">
            <label for="xpbdGamma">Shaping (Î³)</label>
            <input type="number" id="xpbdGamma" min="0.25" max="3" step="0.05" value="1.0">
        </div>
        <div class="control-group row-2" title="Invert XPBD response: treat (score - threshold) as negative">
            <label for="xpbdInvert">Inverse (XPBD)</label>
            <input type="checkbox" id="xpbdInvert">
        </div>
        <div class="control-group row-2" title="Minimum milliseconds between Brain recomputes (0 = none)">
            <label for="brainCooldownMs">Brain cooldown (ms)</label>
            <input type="number" id="brainCooldownMs" min="0" max="1000" step="10" value="0">
        </div>
        
        <!-- PageRank Edge Coloring System -->
        <hr>
        <div class="section-header" style="background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); color: black;">ðŸŽ¨ Edge Coloring System</div>
        <div class="control-group">
            <div style="margin-bottom:6px; font-weight:600">Scoring Mode</div>
            <div class="inline-pair" title="Stationary PageRank over obtuse-edge graph">
                <input type="radio" name="scoreMode" id="scoreModePR" checked>
                <label for="scoreModePR">PageRank (stationary)</label>
            </div>
            <div class="inline-pair" title="Time-bounded directional random walks">
                <input type="radio" name="scoreMode" id="scoreModeMC">
                <label for="scoreModeMC">MC Walk (timeâ€‘bounded)</label>
            </div>
        </div>
        <div class="control-group" id="mcParamsBlock" style="display:none">
            <div style="margin:4px 0 8px; opacity:0.8">MC Parameters</div>
            <div class="row-2" title="Walk horizon (number of steps). Larger explores farther, slower.">
                <label for="mcStepsL">Max Steps (L)</label>
                <input type="number" id="mcStepsL" min="2" max="32" step="1" value="12">
            </div>
            <div class="row-2" title="Number of walkers per start. Higher = smoother colors.">
                <label for="mcWalkersK">Walkers per halfâ€‘edge (K)</label>
                <input type="number" id="mcWalkersK" min="8" max="256" step="8" value="64">
            </div>
            <div class="row-2" title="Discount per step. Lower emphasizes near field.">
                <label for="mcAlpha">Perâ€‘step survival (Î±)</label>
                <input type="number" id="mcAlpha" min="0.75" max="0.98" step="0.01" value="0.90">
            </div>
            <div class="inline-pair" title="Recompute immediately when parameters change (optional)">
                <input type="checkbox" id="mcAutoRecompute">
                <label for="mcAutoRecompute">Autoâ€‘recompute on change</label>
            </div>
        </div>
        <div class="control-group" id="prParamsBlock">
            <div class="row-2" title="Search depth for PageRank iterations">
                <label for="dynSearchDepthNum">PageRank Depth</label>
                <input type="number" id="dynSearchDepthNum" min="5" max="30" step="1" value="15">
            </div>
        </div>
        <div class="control-group row-2">
            <div class="inline-pair" title="Color Voronoi edges by PageRank score"><input type="checkbox" id="colorEdgesByScore"><label>Color Edges by Score</label></div>
            <div class="inline-pair" title="Show edge statistics in status bar"><input type="checkbox" id="showEdgeStats"><label>Show Edge Stats</label></div>
        </div>
        <!-- Discrete color mapping controls -->
        <div class="control-group" id="colorMapControls">
            <div class="row-2">
                <label for="colorSteps" title="Number of discrete color steps">Color steps</label>
                <input type="number" id="colorSteps" min="2" max="10" step="1" value="5">
            </div>
            <div class="row-2">
                <label for="colorPalette" title="Choose color palette">Palette</label>
                <select id="colorPalette">
                    <option value="seq_ryg">Sequential (Redâ†’Yellowâ†’Green)</option>
                    <option value="div_bwr">Diverging (Blueâ†’Whiteâ†’Red)</option>
                    <option value="viridis">Viridis (CBâ€‘safe)</option>
                    <option value="cividis">Cividis (CBâ€‘safe)</option>
                    <option value="turbo">Turbo</option>
                </select>
            </div>
            <div class="row-2">
                <label for="quantization" title="Equal bins or quantiles">Quantization</label>
                <select id="quantization">
                    <option value="equal">Equal bins</option>
                    <option value="quantile">Quantiles</option>
                </select>
            </div>
            <div class="inline-pair" title="Reverse the palette order">
                <input type="checkbox" id="reversePalette">
                <label for="reversePalette">Reverse palette</label>
            </div>
            <div id="colorLegend" style="margin-top:6px; display:flex; gap:4px; align-items:center;"></div>
        </div>
        <div class="control-group row-2">
            <div class="inline-pair" title="Force rainbow colors to test if Three.js rendering works"><input type="checkbox" id="forceRainbowTest"><label>ðŸŒˆ Force Rainbow Test</label></div>
        </div>
         <div class="control-group">
            <button id="computeEdgeScoresBtn" title="Manually compute edge PageRank scores">Compute Edge Scores</button>
            <button id="quickColorBtn" title="Quick setup for colored edges" style="background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); color: black;">ðŸŒˆ Quick Color Demo</button>
        </div>
        
        <!-- Performance & Debug Controls -->
        <div class="section-header">Performance & Debug</div>
        <div class="control-group slider-group" title="Animation frame rate limit">
            <label for="dynFPS">FPS Limit</label>
            <input type="range" id="dynFPS" min="5" max="60" step="1" value="30">
            <input type="number" id="dynFPSNum" min="5" max="60" step="1" value="30">
        </div>
         <div class="control-group">
            <div class="inline-pair" title="Show periodic ghost cells"><input type="checkbox" id="showGhostCells"><label>Ghost Cells</label></div>
        </div>
        <!-- Make VoroX flow toggle visible to control yellow network -->
        <div class="control-group">
            <div class="inline-pair" title="Show VoroX flow (yellow line network)"><input type="checkbox" id="showVoroX"><label>Flow (VoroX)</label></div>
        </div>
        
        <!-- Previously hidden: now visible controls that affect rendering/flow -->
        <div class="control-group" title="Legacy/flow settings that still affect visuals">
            <div class="row-2">
                <label for="dynDecay">Decay:</label>
                <input type="range" id="dynDecay" min="0.8" max="1.0" step="0.005" value="0.95">
            </div>
            <div class="row-2">
                <label for="dynDecayNum">Decay (num):</label>
                <input type="number" id="dynDecayNum" min="0.8" max="1.0" step="0.005" value="0.95">
            </div>
            <div class="row-2">
                <label for="voroxMaxSegs">Flow Segments:</label>
                <input type="range" id="voroxMaxSegs" min="100" max="50000" step="100" value="2000">
            </div>
            <div class="row-2">
                <label for="voroxMaxSegsNum">Flow Segments (num):</label>
                <input type="number" id="voroxMaxSegsNum" min="100" max="20000" step="100" value="2000">
            </div>
            <div class="inline-pair" title="Color faces by score (overrides face color picker)">
                <input type="checkbox" id="voroxColorByScore" checked>
                <label for="voroxColorByScore">Faces: Color by Score</label>
            </div>
            <div class="inline-pair" title="Color flow (VoroX) by score; if off, uses Voronoi Edge Color picker">
                <input type="checkbox" id="flowColorByScore" checked>
                <label for="flowColorByScore">Flow: Color by Score</label>
            </div>
        </div>
        <hr>
        <div class="section-header">Delaunay Triangles / Tetrahedra</div>
        <div class="control-group row-3">
            <div class="sub-label">Vertices</div>
            <div class="sub-label">Delaunay</div>
            <div class="sub-label">Tetrahedra</div>
            <div style="text-align:center"><input type="checkbox" id="showVertices" checked></div>
            <div style="text-align:center"><input type="checkbox" id="showDelaunay" checked></div>
            <div style="text-align:center"><input type="checkbox" id="showTetrahedra" checked></div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Point Size:</label>
                <input type="number" id="delaunaySize" value="0.005" min="0.001" max="0.05" step="0.001">
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="vertexColor" value="#000000">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Edge Width:</label>
                <input type="number" id="delaunayEdgeWidth" value="2" min="1" max="10" step="1" disabled>
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="delaunayEdgeColor" value="#808080">
            </div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Tetra Color:</label>
                <input type="color" id="tetraColor" value="#D3D3D3">
            </div>
            <div>
                <label>Opacity:</label>
                <input type="number" id="tetraOpacity" value="0.01" min="0.0" max="1.0" step="0.01">
            </div>
        </div>
        <hr>
        <div class="section-header">Voronoi Diagrams</div>
        <div class="control-group row-3">
            <div class="sub-label">Vertices</div>
            <div class="sub-label">Edges</div>
            <div class="sub-label">Faces</div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoi"></div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoiEdgesToggle" checked></div>
            <div style="text-align:center"><input type="checkbox" id="showVoronoiFaces" checked></div>
        </div>
        <div class="control-group row-2">
            <div>
                <label>Point Size:</label>
                <input type="number" id="voronoiSize" value="0.005" min="0.001" max="0.05" step="0.001">
            </div>
            <div>
                <label>Color:</label>
                <input type="color" id="voronoiVertexColor" value="#0000FF">
            </div>
        </div>
        <!-- Previously hidden: Voronoi edge styling (used when not coloring by score) -->
        <div class="control-group row-2" title="Voronoi edge styling (ignored when Color Edges by Score is on)">
            <div>
                <label>Edge Width:</label>
                <input type="number" id="voronoiEdgeWidth" value="2" min="1" max="10" step="1">
            </div>
            <div>
                <label>Edge Color:</label>
                <input type="color" id="voronoiEdgeColor" value="#4169E1">
            </div>
        </div>
        <!-- Move Tetra controls to Delaunay section and place Voronoi Method later -->
        <div class="control-group">
            <div class="row-2">
                <div>
                    <label>Faces Color:</label>
                    <input type="color" id="voronoiFaceColor" value="#ADD8E6">
                </div>
                <div>
                    <label>Opacity:</label>
                    <input type="number" id="voronoiFaceOpacity" value="0.04" min="0.0" max="1.0" step="0.01">
                </div>
            </div>
        </div>
        
        <hr>
        <div id="status" class="status"></div>
        <div id="stats" style="font-size:12px; margin-top:8px">
            <span id="statsCore">Loading...</span><br>
            <span id="statsPerf"></span>
        </div>
        <!-- Legend Panel -->
        <div id="legendPanel" class="legend-panel"></div>
        </div>
    </div>
    
    <script src="../../dist/periodic_delaunay.js"></script>
    <script>
        // Make module available on window for compatibility
        if (typeof PeriodicDelaunayModule !== 'undefined' && typeof window.PeriodicDelaunayModule === 'undefined') {
            window.PeriodicDelaunayModule = PeriodicDelaunayModule;
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { DelaunayComputation } from '../../src/js/DelaunayComputation.js';
        import { createVoroX } from '../../src/js/VoroXAdapter.js';
        import { barycenter } from '../../src/js/vorox2/core.js';
        import { calculateScores, calculateEdgeScores, calculateEdgeScoresMonteCarlo, gradient, integratePoints, createVerletSystem } from '../../src/js/vorox2/dynamics.js';
        import PoissonDiskSampling from "https://esm.sh/poisson-disk-sampling@2.3.0";
        
        let scene, camera, renderer, controls;
        let verticesGroup, delaunayGroup, voronoiGroup, voronoiFacesGroup, tetrahedraGroup, voroxGroup, boundaryGroup, ghostCellsGroup;
        let Module;
        let currentPoints = [];
        let voroxInstance = null;
        let live = false;
        let rafId = 0;
        let lastFrameTime = performance.now();
        let lastFPSUpdate = performance.now();
        let scores = [];
        let verletIntegrator = null;  // Verlet physics integrator
        let lastEdgeScores = null;    // Cached edge scores (PR or MC)
        let lastScoreMethod = null;   // 'pagerank' | 'mc'
        let lastScoreParams = null;   // params used for last compute
        let lastScoreTimestamp = null;// Date.now()
        let lastFoamHash = null;      // topology hash to avoid stale reuse
        // Brain worker state
        let brainWorker = null;
        let brainInFlight = false;
        let pendingSig = null;
        let brainLastTimeMs = 0;
        let physStepsSinceBrain = 0;
        let runPhase = 'physical';
        let lastBrainSig = null;      // JSON signature of last Brain compute
        let overlayEl = null;         // overlay element for long-running computes
        
        // Discrete color mapping cache/state
        let colorSteps = 5;
        let paletteId = 'seq_ryg';
        let quantization = 'equal';
        let reversePalette = false;
        let cachedThresholds = null;
        let cachedStepColors = null;
        let cachedScoreHash = null;

        function setStatus(message, isSuccess = true) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${isSuccess ? 'success' : 'error'}`;
        }
        
        // --- Discrete color mapping helpers (module scope) ---
        function getPaletteAnchors(id){
            switch(id){
                case 'div_bwr': return ['#313695','#FFFFFF','#A50026'];
                case 'viridis': return ['#440154','#414487','#2A788E','#22A884','#7AD151','#FDE725'];
                case 'cividis': return ['#00204C','#2E4A7D','#4B6B8A','#6C8C89','#94AB73','#D3C95A','#FDE945'];
                case 'turbo': return ['#30123B','#4145AD','#2CA8F7','#39D353','#EEF921','#F98E09','#C01A1B'];
                case 'seq_ryg':
                default: return ['#FF0000','#FFFF00','#00FF00'];
            }
        }
        function lerpColor(c1,c2,t){
            const a=new THREE.Color(c1),b=new THREE.Color(c2),out=new THREE.Color();
            out.r=a.r+(b.r-a.r)*t; out.g=a.g+(b.g-a.g)*t; out.b=a.b+(b.b-a.b)*t; return out;
        }
        function buildStepColors(steps, id, reverse){
            const anchors=getPaletteAnchors(id);
            const m=anchors.length-1;
            const arr=[];
            for(let i=0;i<steps;i++){
                const u=steps===1?0:i/(steps-1);
                const x=u*m, k=Math.min(m-1, Math.floor(x));
                const t=x-k; arr.push(lerpColor(anchors[k], anchors[k+1], t));
            }
            if(reverse) arr.reverse();
            return arr;
        }
        function binarySearchThresholds(th, s){
            let lo=0, hi=th.length; while(lo<hi){const mid=(lo+hi>>>1); if(s<th[mid]) hi=mid; else lo=mid+1;} return lo;
        }
        function hashScores(map){
            if(!map||map.size===0) return '0';
            let h=0; let i=0;
            for(const v of map.values()){ const x=Math.floor(v*1000); h=(h*1315423911 ^ x)>>>0; if(++i>2048) break; }
            return String(h>>>0);
        }
        function ensureColorMappingCache(){
            if(!lastEdgeScores||lastEdgeScores.size===0) { cachedThresholds=null; cachedStepColors=null; cachedScoreHash=null; return; }
            const scoreHash=hashScores(lastEdgeScores);
            if(cachedThresholds && cachedStepColors && cachedScoreHash===`${paletteId}|${colorSteps}|${quantization}|${reversePalette}|${scoreHash}`) return;
            // thresholds
            let th=null;
            if(quantization==='quantile'){
                const vals=Array.from(lastEdgeScores.values()).slice().sort((a,b)=>a-b);
                th=[]; for(let i=1;i<colorSteps;i++){ const p=i/colorSteps; const idx=Math.min(vals.length-1, Math.max(0, Math.floor(p*(vals.length-1)))); th.push(vals[idx]); }
            } else {
                th=[]; for(let i=1;i<colorSteps;i++){ th.push(i/colorSteps); }
            }
            cachedThresholds=th;
            cachedStepColors=buildStepColors(colorSteps, paletteId, reversePalette);
            cachedScoreHash=`${paletteId}|${colorSteps}|${quantization}|${reversePalette}|${scoreHash}`;
            // optional: legacy mini legend swatches
            const legend=document.getElementById('colorLegend'); if(legend){ legend.innerHTML=''; const total=colorSteps; for(let i=0;i<total;i++){ const sw=document.createElement('div'); sw.style.cssText='width:18px;height:12px;border:1px solid #888'; sw.style.background=`#${cachedStepColors[i].getHexString()}`; legend.appendChild(sw);} }
        }
        function edgeScoreToColor(score) {
            const s=Math.max(0, Math.min(1, score||0));
            ensureColorMappingCache();
            if(!cachedStepColors){ const c=new THREE.Color(); c.setHSL(s*0.33,1.0,0.5); return c; }
            let bin=0;
            if(quantization==='quantile' && cachedThresholds){ bin=binarySearchThresholds(cachedThresholds, s); }
            else { bin=Math.floor(s*colorSteps - 1e-8); if(bin<0) bin=0; if(bin>=colorSteps) bin=colorSteps-1; }
            return cachedStepColors[bin].clone();
        }
        // --- Legend computation and rendering (module scope) ---
        function computeLegendBins() {
            if (!lastEdgeScores || lastEdgeScores.size === 0) return null;
            ensureColorMappingCache();
            const edges = [0, ...(cachedThresholds||[]), 1];
            const counts = new Array(colorSteps).fill(0);
            const total = lastEdgeScores.size;
            for (const s of lastEdgeScores.values()) {
                let b;
                if (quantization === 'quantile' && cachedThresholds) b = binarySearchThresholds(cachedThresholds, s);
                else { b = Math.floor(s*colorSteps - 1e-8); if (b<0) b=0; if (b>=colorSteps) b=colorSteps-1; }
                counts[b]++;
            }
            const percents = counts.map(c => total ? (c/total) : 0);
            return { edges, counts, percents, total };
        }
        function legendRangeLabel(i, edges) {
            if (quantization === 'quantile') {
                const p0 = Math.round((i   / colorSteps)*100);
                const p1 = Math.round(((i+1)/ colorSteps)*100);
                return `P${p0}â€“P${p1}`;
            }
            const a = edges[i];
            const b = edges[i+1];
            return `${a.toFixed(2)}â€“${b.toFixed(2)}`;
        }
        function computeBalance(percents) {
            if (!percents) return 0;
            const u = 1/colorSteps;
            let sum = 0; for (const p of percents) sum += Math.abs(p - u);
            const denom = 2*(1 - u);
            return Math.max(0, Math.min(1, 1 - (sum/denom)));
        }
        function renderLegend() {
            const panel = document.getElementById('legendPanel'); if (!panel) return;
            if (!lastEdgeScores || lastEdgeScores.size === 0) { panel.innerHTML = ''; return; }
            ensureColorMappingCache();
            const bins = computeLegendBins(); if (!bins) { panel.innerHTML=''; return; }
            const { edges, counts, percents, total } = bins;
            const thr = parseFloat(document.getElementById('dynThresholdNum')?.value || '0.5');
            // determine bin index for threshold upper split
            let thrBin = 0; if (quantization==='quantile' && cachedThresholds) thrBin = binarySearchThresholds(cachedThresholds, thr); else { thrBin = Math.floor(thr*colorSteps - 1e-8); if (thrBin<0) thrBin=0; if (thrBin>=colorSteps) thrBin=colorSteps-1; }
            let html = '<div class="legend-title">Edge Weights</div>';
            for (let i=0;i<colorSteps;i++) {
                const col = `#${cachedStepColors[i].getHexString()}`;
                const range = legendRangeLabel(i, edges);
                const cnt = counts[i];
                const pct = Math.round(percents[i]*100);
                html += `<div class="legend-row" style="opacity:${(colorSteps>1)?1:1}"><div class="legend-left"><span class="legend-swatch" style="background:${col}"></span><span class="legend-range">${range}</span></div><div class="legend-count">(${cnt}${total?`, ${pct}%`:''})</div></div>`;
            }
            const balance = Math.round(computeBalance(percents)*100);
            html += `<div class="legend-footer">Balance: ${balance}%</div>`;
            html += `<div style=\"display:flex; gap:6px; margin-top:6px;\"><button id=\"legendMedianBtn\" style=\"flex:1\">Median (50%)</button><button id=\"legendBalanceBtn\" style=\"flex:1\">Balance split</button></div>`;
            panel.innerHTML = html;
            // Click handlers
            const rows = panel.querySelectorAll('.legend-row');
            rows.forEach((row, i) => {
                row.onclick = () => {
                    // set threshold to upper edge of bin i
                    const upper = edges[i+1];
                    const thrInput = document.getElementById('dynThresholdNum');
                    const thrSlider = document.getElementById('dynThreshold');
                    if (thrInput) thrInput.value = upper.toFixed(2);
                    if (thrSlider) thrSlider.value = upper.toFixed(2);
                    setStatus(`Threshold set to ${upper.toFixed(2)} via legend`, true);
                    updateScene(); renderLegend();
                };
            });
            const medianBtn = document.getElementById('legendMedianBtn');
            if (medianBtn) medianBtn.onclick = () => {
                let m=0.5; if (quantization==='quantile' && cachedThresholds && cachedThresholds.length) { m = cachedThresholds[Math.floor(cachedThresholds.length/2)] || 0.5; }
                const thrInput = document.getElementById('dynThresholdNum'); const thrSlider=document.getElementById('dynThreshold');
                if (thrInput) thrInput.value = m.toFixed(2); if (thrSlider) thrSlider.value=m.toFixed(2);
                setStatus('Threshold set to median', true); updateScene(); renderLegend();
            };
            const balanceBtn = document.getElementById('legendBalanceBtn');
            if (balanceBtn) balanceBtn.onclick = () => {
                // choose split minimizing |left% - right%|
                const cum=[]; let acc=0; for (let i=0;i<percents.length;i++){ acc+=percents[i]; cum.push(acc); }
                let bestI=0, bestD=1e9; for (let i=0;i<cum.length;i++){ const d=Math.abs(cum[i]-0.5); if (d<bestD){ bestD=d; bestI=i; } }
                const t = edges[bestI+1];
                const thrInput = document.getElementById('dynThresholdNum'); const thrSlider=document.getElementById('dynThreshold');
                if (thrInput) thrInput.value = t.toFixed(2); if (thrSlider) thrSlider.value=t.toFixed(2);
                setStatus('Threshold set to balanced split', true); updateScene(); renderLegend();
            };
        }
        
        // Initialize Three.js
        function initThree() {
            if (renderer) return; // prevent multiple WebGL context creations
            scene = new THREE.Scene();
            const bgHex = document.getElementById('backgroundColor').value || '#c2c2c2';
            scene.background = new THREE.Color(bgHex);
            
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(1.5, 1.5, 1.5);
            camera.lookAt(0.5, 0.5, 0.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.5, 0.5, 0.5);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Hide/Show controls toggle
            const toggleBtn = document.getElementById('controls-toggle');
            const controlsPanel = document.getElementById('controls');
            const legendPanel = document.getElementById('legendPanel');
            toggleBtn.addEventListener('click', () => {
                controlsPanel.classList.toggle('hidden');
                toggleBtn.textContent = controlsPanel.classList.contains('hidden') ? 'show' : 'hide';
                if (legendPanel) legendPanel.style.display = controlsPanel.classList.contains('hidden') ? 'none' : '';
            });
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Groups
            verticesGroup = new THREE.Group();
            delaunayGroup = new THREE.Group();
            voronoiGroup = new THREE.Group();
            voronoiFacesGroup = new THREE.Group();
            tetrahedraGroup = new THREE.Group();
            voroxGroup = new THREE.Group();
            boundaryGroup = new THREE.Group();
            ghostCellsGroup = new THREE.Group();
            
            scene.add(verticesGroup);
            scene.add(delaunayGroup);
            scene.add(voronoiGroup);
            scene.add(voronoiFacesGroup);
            scene.add(tetrahedraGroup);
            scene.add(voroxGroup);
            scene.add(boundaryGroup);
            scene.add(ghostCellsGroup);
            
            // Create boundary box
            createBoundaryBox();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createBoundaryBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 })
            );
            line.position.set(0.5, 0.5, 0.5);
            boundaryGroup.add(line);
            
            // Add axes helpers (toggle with boundary)
            const axesHelper = new THREE.AxesHelper(0.2);
            axesHelper.name = 'axesHelper';
            scene.add(axesHelper);
            
            // Ghost cell tiling drawn by drawGhostCells when enabled
        }

        // Ghost cells tiling (26 neighbors) using boundary boxes for now
        function createGhostCellTiling() {
            // Cleanup
            ghostCellsGroup.clear();
            if (!document.getElementById('showGhostCells').checked || !voroxInstance || !voroxInstance.getFoam().isPeriodic) return;

            const foam = voroxInstance.getFoam();
            const delaunayVisible = document.getElementById('showDelaunay').checked;
            const voronoiVisible = document.getElementById('showVoronoiEdgesToggle').checked;

            if (!delaunayVisible && !voronoiVisible) return;

            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const ghostDelaunayMat = new THREE.LineBasicMaterial({ color: delaunayEdgeColorHex, opacity: 0.2, transparent: true });
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const ghostVoronoiMat = new THREE.LineBasicMaterial({ color: voronoiEdgeColorHex, opacity: 0.15, transparent: true });

            // Build base geometries once
            const buildDelaunayGeom = () => {
                const positions = [];
                const edgeSet = new Set();
                for (const tet of foam.simplices) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a, b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (edgeSet.has(key)) continue; edgeSet.add(key);
                        const p1 = foam.points[a];
                        const p2 = getMinimumImage(p1, foam.points[b]);
                        positions.push(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
                    }
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geom;
            };
            const buildVoronoiGeom = () => {
                const positions = [];
                const vizCenters = foam.simplices.map(tet => barycenter(foam.points, tet, foam.isPeriodic));
                const done = new Set();
                for (let ti=0; ti<foam.facetPairs.length; ti++) {
                    for (let fi=0; fi<4; fi++) {
                        const m = foam.facetPairs[ti][fi];
                        if (!m) continue;
                        const a=ti, b=m.tet;
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (done.has(key)) continue; done.add(key);
                        const c1 = vizCenters[a];
                        const c2raw = vizCenters[b];
                        const c2 = getMinimumImage(c1, c2raw);
                        positions.push(c1[0], c1[1], c1[2], c2[0], c2[1], c2[2]);
                    }
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geom;
            };

            const delaunayGeom = delaunayVisible ? buildDelaunayGeom() : null;
            const voronoiGeom = voronoiVisible ? buildVoronoiGeom() : null;

            const offsets = [];
            for (let x=-1; x<=1; x++) for (let y=-1; y<=1; y++) for (let z=-1; z<=1; z++) {
                if (x===0 && y===0 && z===0) continue;
                offsets.push([x,y,z]);
            }

            for (const [ox, oy, oz] of offsets) {
                const g = new THREE.Group();
                g.position.set(ox, oy, oz);
                if (delaunayGeom) g.add(new THREE.LineSegments(delaunayGeom, ghostDelaunayMat));
                if (voronoiGeom) g.add(new THREE.LineSegments(voronoiGeom, ghostVoronoiMat));
                ghostCellsGroup.add(g);
            }
        }
        
        // Generate well-distributed points using Poisson disk sampling
        function generatePoissonPoints(targetCount, minDistance) {
            console.log(`Generating ~${targetCount} points with min distance ${minDistance}...`);
            
            // For now, use a simpler approach that works better
            const points = [];
            const maxAttempts = targetCount * 100;
            let attempts = 0;
            
            // Add small margin to keep points away from boundaries
            const margin = 0.01;
            
            while (points.length < targetCount && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin)
                ];
                
                // Check minimum distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with minimum distance checking`);
            return points;
        }
        
        // Legacy function for comparison (keeping for now)
        function generateWellDistributedPoints(count, minDist) {
            const points = [];
            let attempts = 0;
            const maxAttempts = count * 1000;
            
            while (points.length < count && attempts < maxAttempts) {
                attempts++;
                const newPoint = [Math.random(), Math.random(), Math.random()];
                
                // Check distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            return points;
        }
        
        // Helper function to calculate minimum image for periodic boundaries
        function getMinimumImage(p1, p2) {
            let dx = p2[0] - p1[0];
            let dy = p2[1] - p1[1];
            let dz = p2[2] - p1[2];

            // Apply periodic boundary conditions
            if (dx > 0.5) dx -= 1.0; else if (dx < -0.5) dx += 1.0;
            if (dy > 0.5) dy -= 1.0; else if (dy < -0.5) dy += 1.0;
            if (dz > 0.5) dz -= 1.0; else if (dz < -0.5) dz += 1.0;

            return [p1[0] + dx, p1[1] + dy, p1[2] + dz];
        }
        
        function calculateAcuteCornerScores(foam) {
            const numPoints = foam.points.length;
            const scores = Array(numPoints).fill(0);
            const counts = Array(numPoints).fill(0);

            for (const tet of foam.simplices) {
                const p = tet.map(i => foam.points[i]);
                for (let i=0; i<4; i++) {
                    const p_idx = tet[i];
                    const p0 = p[i];
                    const others = p.filter((_, idx) => idx !== i);
                    
                    let acute_corners = 0;
                    // Simplified: check angles at p0 formed by other 3 points
                    const v1 = [others[0][0]-p0[0], others[0][1]-p0[1], others[0][2]-p0[2]];
                    const v2 = [others[1][0]-p0[0], others[1][1]-p0[1], others[1][2]-p0[2]];
                    const v3 = [others[2][0]-p0[0], others[2][1]-p0[1], others[2][2]-p0[2]];
                    const n1 = Math.hypot(...v1), n2 = Math.hypot(...v2), n3 = Math.hypot(...v3);

                    if (n1*n2 > 1e-9 && (v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]) / (n1*n2) > 0) acute_corners++;
                    if (n1*n3 > 1e-9 && (v1[0]*v3[0] + v1[1]*v3[1] + v1[2]*v3[2]) / (n1*n3) > 0) acute_corners++;
                    if (n2*n3 > 1e-9 && (v2[0]*v3[0] + v2[1]*v3[1] + v2[2]*v3[2]) / (n2*n3) > 0) acute_corners++;

                    scores[p_idx] += acute_corners;
                    counts[p_idx]++;
                }
            }
            
            for (let i=0; i<numPoints; i++) {
                if (counts[i] > 0) scores[i] /= counts[i];
            }
            return scores;
        }
        
        // Visualize vertices
        function drawVertices(points) {
            verticesGroup.clear();
            const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
            const vertexColorHex = document.getElementById('vertexColor').value;
            const material = new THREE.MeshPhongMaterial({ color: vertexColorHex });
            const geometry = new THREE.SphereGeometry(vertexSize, 12, 12);
            for (const p of points) {
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(p[0], p[1], p[2]);
                verticesGroup.add(sphere);
            }
        }
        
        // Visualize Delaunay edges
        function drawDelaunay(foam) {
            delaunayGroup.clear();
            if (!document.getElementById('showDelaunay').checked) { delaunayGroup.visible = false; return; }
            delaunayGroup.visible = true;
            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const material = new THREE.LineBasicMaterial({ color: delaunayEdgeColorHex });
            const positions = [];
            const edgeSet = new Set();
            for (const tet of foam.simplices) {
                const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (edgeSet.has(key)) continue;
                        edgeSet.add(key);
                    const p1 = foam.points[a];
                    const useMIC = document.getElementById('useMIC').checked;
                    const p2 = (foam.isPeriodic && useMIC) ? getMinimumImage(p1, foam.points[b]) : foam.points[b];
                    positions.push(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
                }
            }
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            delaunayGroup.add(new THREE.LineSegments(geom, material));
        }

        function parseNumInput(elId, fallback) {
            const v = (document.getElementById(elId).value || '').toString().replace(',', '.');
            const n = parseFloat(v);
            return Number.isFinite(n) ? n : fallback;
        }

        function calculateVoronoiVertexScores(foam) {
            const numTets = foam.simplices.length;
            const scores = Array(numTets).fill(0);
            const centers = foam.centers;

            for (let i=0; i<numTets; i++) {
                const center = centers[i];
                if (!center) continue;

                const neighbors = foam.facetPairs[i]
                    .filter(Boolean)
                    .map(m => centers[m.tet]);
                
                if (neighbors.length < 2) continue;

                const vectors = neighbors.map(n => {
                    const v = [n[0]-center[0], n[1]-center[1], n[2]-center[2]];
                    const norm = Math.hypot(...v);
                    return norm > 1e-9 ? [v[0]/norm, v[1]/norm, v[2]/norm] : null;
                }).filter(Boolean);

                let acuteCount = 0;
                for (let j=0; j<vectors.length; j++) {
                    for (let k=j+1; k<vectors.length; k++) {
                        const dot = vectors[j][0]*vectors[k][0] + vectors[j][1]*vectors[k][1] + vectors[j][2]*vectors[k][2];
                        if (dot > 0) { // Angle is acute
                            acuteCount++;
                        }
                    }
                }
                scores[i] = acuteCount;
            }
            return scores;
        }

        // Draw Voronoi vertices/edges and VoroX flow using foam structure
        function drawVoronoiAndFlow(foam) {
            console.log('ðŸ“ drawVoronoiAndFlow called');
            
            // IMPORTANT: Clear groups to remove old geometry
            console.log('  Clearing voronoiGroup (had', voronoiGroup.children.length, 'children)');
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            voroxGroup.clear();
            if (!foam) return;

            const showVoronoiVerts = document.getElementById('showVoronoi').checked;
            const showVoronoiEdges = document.getElementById('showVoronoiEdgesToggle').checked;
            const showVoronoiFaces = document.getElementById('showVoronoiFaces').checked;
            const showFlow = document.getElementById('showVoroX').checked;
            const facesColorByScore = document.getElementById('voroxColorByScore').checked;
            const flowColorByScore = document.getElementById('flowColorByScore').checked;
            const colorEdgesByScore = document.getElementById('colorEdgesByScore').checked;
            const showEdgeStats = document.getElementById('showEdgeStats').checked;

            // Debug: Check what's controlling visibility
            console.log('ðŸ” Visibility Debug:');
            console.log('  showVoronoiVerts:', showVoronoiVerts);
            console.log('  showVoronoiEdges:', showVoronoiEdges);
            console.log('  Setting voronoiGroup.visible to:', showVoronoiVerts || showVoronoiEdges);
            voronoiGroup.visible = showVoronoiVerts || showVoronoiEdges;
            voronoiFacesGroup.visible = showVoronoiFaces;
            voroxGroup.visible = showFlow;

            const vizCenters = foam.simplices.map(tet => barycenter(foam.points, tet, foam.isPeriodic));

            let maxScore = 0;
            if (facesColorByScore && scores.length > 0) {
                for(const s of scores) maxScore = Math.max(maxScore, s);
            }
            function scoreToColor(s) {
                const t = Math.max(0, Math.min(1, s / (maxScore || 1)));
                const c = new THREE.Color();
                // Invert t for dark green (high) to yellow (low)
                // HSL: Hue, Saturation, Lightness
                // Green is around 0.33, Yellow is around 0.16
                c.setHSL(0.16 + (0.17 * (1-t)), 0.9, 0.45); 
                return c;
            }
            
            // Note: legend/color-mapping helpers are now defined at module scope

            if (showVoronoiFaces) {
                const faceColorHex = document.getElementById('voronoiFaceColor').value;
                const faceOpacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
                const cells = new Map();
                foam.simplices.forEach((tet, index) => {
                    const center = vizCenters[index];
                    if (!center) return;
                    tet.forEach(vertexIndex => {
                        if (!cells.has(vertexIndex)) cells.set(vertexIndex, []);
                        cells.get(vertexIndex).push({center: new THREE.Vector3(...center), tetId: index});
                    });
                });
                cells.forEach((cellData) => {
                    if (cellData.length < 4) return;
                    const useMIC = document.getElementById('useMIC').checked;
                    const ref = cellData[0].center;
                    const adjusted = cellData.map(d => {
                        const out = d.center.clone();
                        if (!(foam.isPeriodic && useMIC)) return out;
                        for (let k=0;k<3;k++) {
                            let diff = d.center.getComponent(k) - ref.getComponent(k);
                            if (diff > 0.5) out.setComponent(k, d.center.getComponent(k) - 1.0);
                            else if (diff < -0.5) out.setComponent(k, d.center.getComponent(k) + 1.0);
                        }
                        return out;
                    });
                    const geom = new ConvexGeometry(adjusted);
                const color = facesColorByScore ? scoreToColor(scores[cellData[0].tetId]) : new THREE.Color(faceColorHex);
                    const mat = new THREE.MeshPhongMaterial({ color, opacity: faceOpacity, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    voronoiFacesGroup.add(new THREE.Mesh(geom, mat));
                });
            }

            if (showFlow) {
                const maxSegs = parseInt(document.getElementById('voroxMaxSegsNum').value);
                const useMIC = document.getElementById('useMIC').checked;
                let drawn = 0;
                const done = new Set();

                for (let t1_idx = 0; t1_idx < foam.facetPairs.length; t1_idx++) {
                    if (drawn >= maxSegs) break;
                    for (const mirror of foam.facetPairs[t1_idx]) {
                        if (!mirror || drawn >= maxSegs) continue;
                        
                        const t2_idx = mirror.tet;
                        const key = t1_idx < t2_idx ? `${t1_idx}-${t2_idx}` : `${t2_idx}-${t1_idx}`;
                        if (done.has(key)) continue;
                        done.add(key);

                        const c1 = vizCenters[t1_idx];
                        const c2_raw = vizCenters[t2_idx];
                        if (!c1 || !c2_raw) continue;

                        const c2 = (foam.isPeriodic && useMIC) ? getMinimumImage(c1, c2_raw) : c2_raw;
                        let color;
                        if (flowColorByScore) {
                            const edgeKey = t1_idx < t2_idx ? `${t1_idx}-${t2_idx}` : `${t2_idx}-${t1_idx}`;
                            const prScore = lastEdgeScores && lastEdgeScores.get ? lastEdgeScores.get(edgeKey) : undefined;
                            color = (prScore !== undefined) ? edgeScoreToColor(prScore)
                                : new THREE.Color(document.getElementById('voronoiEdgeColor').value || '#ff00aa');
                        } else {
                            color = new THREE.Color(document.getElementById('voronoiEdgeColor').value || '#ff00aa');
                        }
                        const mat = new THREE.LineBasicMaterial({ color, opacity: 0.95, transparent: true });
                        const g = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...c1), new THREE.Vector3(...c2) ]);
                        voroxGroup.add(new THREE.Line(g, mat));
                        drawn++;
                    }
                }
            }

            const voronoiAcutenessScores = calculateVoronoiVertexScores(foam);
            const colorMap = [0x0000ff, 0xffa500, 0xff0000, 0x800080, 0x000000, 0x000000, 0x000000];

            // Voronoi vertices as spheres
            if (showVoronoiVerts) {
                const size = parseFloat(document.getElementById('voronoiSize').value);
                const sphereGeom = new THREE.SphereGeometry(size, 8, 8);
                for (let i=0; i<vizCenters.length; i++) {
                    const c = vizCenters[i];
                    const score = voronoiAcutenessScores[i];
                    const color = colorMap[score] !== undefined ? colorMap[score] : 0xcccccc; // Default grey
                    const sphereMat = new THREE.MeshPhongMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
                    const s = new THREE.Mesh(sphereGeom, sphereMat);
                    s.position.set(c[0], c[1], c[2]);
                    voronoiGroup.add(s);
                }
            }
        }
        
        // OLD FUNCTION - NOT USED ANYMORE - Kept for reference only
        // Visualize Voronoi edges
        function drawVoronoi_OLD_UNUSED(computation) {
            voronoiGroup.clear();
            
            if (computation.voronoiEdges.length === 0) return;
            
            const voronoiColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiColorInt = parseInt(voronoiColorHex.substring(1), 16);
            
            const material = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt,
                linewidth: 2 
            });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiColorInt, 
                linewidth: 2,
                opacity: 0.8,
                transparent: true
            });
            
            for (const edge of computation.voronoiEdges) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    edge.start[0], edge.start[1], edge.start[2],
                    edge.end[0], edge.end[1], edge.end[2]
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(
                    geometry, 
                    edge.isPeriodic ? periodicMaterial : material
                );
                voronoiGroup.add(line);
            }
            
            // Also draw the barycenters as small spheres
            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiColorInt,
                emissive: voronoiColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }
        }
        
        // OLD FUNCTION - NOT USED ANYMORE 
        function drawVoronoiFaces_OLD_UNUSED(computation) {
            voronoiFacesGroup.clear();
            
            // Support faces for both barycenter and circumcenter methods; limit point count for perf
            const maxPointsForFaces = 300;
            const showFaces = document.getElementById('showVoronoiFaces').checked;
            voronoiFacesGroup.visible = showFaces;
            if (!showFaces) return;
            if (computation.numPoints > maxPointsForFaces) {
                console.log(`Skipping faces: points=${computation.numPoints} > ${maxPointsForFaces}`);
                return;
            }
            if (!computation.tetrahedra.length || !computation.barycenters.length) return;
            
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: voronoiFaceColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false // Important for transparent objects
            });
            
            // Map each original vertex to the centers (barycenters==circumcenters in this mode)
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const center = computation.barycenters[index];
                if (!center) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(new THREE.Vector3(...center));
                });
            });

            // For each cell, compute the convex hull of its vertices (centers)
            let built = 0;
            cells.forEach((cellVertices) => {
                if (cellVertices.length < 4) return; // Need at least 4 points for a 3D shape

                // Create a convex geometry from the vertices of the Voronoi cell
                // Apply MIC to bring all vertices to the same periodic image as the first vertex
                const ref = cellVertices[0];
                const adjusted = cellVertices.map(v => {
                    const out = v.clone();
                    if (!computation.isPeriodic) return out;
                    for (let k = 0; k < 3; k++) {
                        let diff = v.getComponent(k) - ref.getComponent(k);
                        if (diff > 0.5) out.setComponent(k, v.getComponent(k) - 1.0);
                        else if (diff < -0.5) out.setComponent(k, v.getComponent(k) + 1.0);
                    }
                    return out;
                });

                const geometry = new ConvexGeometry(adjusted);
                const mesh = new THREE.Mesh(geometry, material);
                voronoiFacesGroup.add(mesh);
                built++;
            });
            console.log(`Built ${built} Voronoi cell meshes`);
        }
        
        // OLD FUNCTION - NOT USED ANYMORE
        function drawMeshes_OLD_UNUSED(computation) {
            delaunayGroup.clear();
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            voroxGroup.clear();

            console.log(`Drawing meshes for ${computation.isPeriodic ? 'PERIODIC' : 'NON-PERIODIC'} mode`);

            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const delaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt });
            const delaunayPeriodicMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt, linewidth: 2, opacity: 0.6, transparent: true });

            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2 });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2, opacity: 0.8, transparent: true });
            
            let periodicEdgeCount = 0;
            let regularEdgeCount = 0;
            
            // --- Draw Delaunay Edges ---
            const useMIC = document.getElementById('useMIC').checked;
            const delaunayEdgeSet = new Set();
            const thickDelaunayWidth = parseFloat(document.getElementById('delaunayEdgeWidth').value);
            const thickVoronoiWidth = parseFloat(document.getElementById('voronoiEdgeWidth').value);
            if (useMIC) {
                // Thick edges using MIC
                const delaunayGeom = new LineGeometry();
                const delaunayPositions = [];
                for (const tet of computation.tetrahedra) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a,b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (delaunayEdgeSet.has(key)) continue;
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.isPeriodic ? getMinimumImage(p1, computation.pointsArray[b]) : computation.pointsArray[b];
                        delaunayPositions.push(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]);
                    }
                }
                delaunayGeom.setPositions(delaunayPositions);
                const delaunayMat = new LineMaterial({ color: delaunayEdgeColorInt, linewidth: thickDelaunayWidth, resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) });
                const delaunayLine = new Line2(delaunayGeom, delaunayMat);
                delaunayLine.computeLineDistances();
                delaunayGroup.add(delaunayLine);
            } else {
                // Thin edges (existing path with MIC per-edge)
                for (const tet of computation.tetrahedra) {
                    const edges = [[tet[0],tet[1]],[tet[0],tet[2]],[tet[0],tet[3]],[tet[1],tet[2]],[tet[1],tet[3]],[tet[2],tet[3]]];
                    for (const [a,b] of edges) {
                        const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                        if (delaunayEdgeSet.has(key)) continue;
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.isPeriodic ? getMinimumImage(p1, computation.pointsArray[b]) : computation.pointsArray[b];
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(...p1), new THREE.Vector3(...p2) ]);
                        delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                    }
                }
            }

            console.log(`Drew ${periodicEdgeCount} periodic edges out of ${delaunayEdgeSet.size} total Delaunay edges`);
            
            // NOTE: Voronoi edges and vertices are now handled by drawVoronoiAndFlow()
            // This function should ONLY draw Delaunay edges

            // Draw VoroX flow if enabled
            if (document.getElementById('showVoroX').checked) {
                const centers = computation.barycenters;
                const faceAdj = computation.getFaceAdjacency();
                const flow = buildVoroXFlow({ tetrahedra: computation.tetrahedra, centers, faceAdjacency: faceAdj });
                const colorByKnot = document.getElementById('voroxColorByScore').checked;
                const maxSegs = parseInt(document.getElementById('voroxMaxSegs').value);
                voroxFlowCache = flow;
                voroxCenters = centers;

                let drawn = 0;
                for (let ti = 0; ti < flow.activeEdges.length; ti++) {
                    for (let fi = 0; fi < 4; fi++) {
                        if (drawn >= maxSegs) break;
                        const nxt = flow.activeEdges[ti][fi];
                        if (!nxt) continue;
                        let c1 = centers[ti];
                        let c2 = centers[nxt.tet];
                        if (computation.isPeriodic) {
                            c2 = getMinimumImage(c1, c2);
                        }
                        // Knot-based coloring removed; always use picker or score elsewhere
                        // Use Voronoi Edge color picker when not score-colored; PR-based color handled in the other flow block
                        const col = new THREE.Color(document.getElementById('voronoiEdgeColor').value || '#ff00aa');
                        const mat = new THREE.LineBasicMaterial({ color: col.getHex(), opacity: 0.9, transparent: true });
                        const g = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                        ]);
                        voroxGroup.add(new THREE.Line(g, mat));
                        drawn++;
                    }
                }

                // Knot highlighting removed
                // Initialize tracers if animation is on
                if (document.getElementById('animateVoroXFlow').checked) {
                    initVoroxTracers(flow, centers);
                } else {
                    clearVoroxTracers();
                }
            }
        }
        
        // Visualize tetrahedra
        function drawTetrahedra(computation) {
            tetrahedraGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const tetraColorHex = document.getElementById('tetraColor').value;
            const tetraColorInt = parseInt(tetraColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('tetraOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: tetraColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (const tet of computation.tetrahedra) {
                const vertices = tet.map(i => computation.pointsArray[i]);
                
                // Create tetrahedron faces
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Face indices for tetrahedron
                const faces = [
                    [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
                ];
                
                for (const face of faces) {
                    for (const idx of face) {
                        positions.push(vertices[idx][0], vertices[idx][1], vertices[idx][2]);
                    }
                }
                
                geometry.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(positions), 3)
                );
                geometry.computeVertexNormals();
                
                const mesh = new THREE.Mesh(geometry, material);
                tetrahedraGroup.add(mesh);
            }
        }
        
        // OLD FUNCTION - NOT USED ANYMORE
        function drawVoroX2_OLD_UNUSED(foam) {
            voronoiGroup.clear();
            voronoiFacesGroup.clear();
            voroxGroup.clear();

            console.log(`Drawing VoroX2 for ${foam.simplices.length} tets, ${foam.knots.length} knots`);

            const voronoiVertexSize = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const voronoiFaceColorHex = document.getElementById('voronoiFaceColor').value;
            const voronoiFaceColorInt = parseInt(voronoiFaceColorHex.substring(1), 16);

            const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2 });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt, linewidth: 2, opacity: 0.8, transparent: true });
            const voronoiFaceMaterial = new THREE.MeshPhongMaterial({
                color: voronoiFaceColorInt,
                opacity: parseFloat(document.getElementById('voronoiFaceOpacity').value),
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            // Draw Voronoi vertices (barycenters or circumcenters)
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            // Use foam.centers (which exists) instead of foam.barycenters (which might not)
            const centers = foam.centers || foam.barycenters || [];
            for (const center of centers) {
                if (!center) continue;
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiGroup.add(sphere);
            }

            // Create default materials for Voronoi edges (neutral gray when not colored by score)
            const defaultVoronoiMaterial = new THREE.LineBasicMaterial({ 
                color: 0x888888,  // Neutral gray
                linewidth: 2 
            });
            const defaultVoronoiPeriodicMaterial = new THREE.LineBasicMaterial({ 
                color: 0x888888,  // Neutral gray
                linewidth: 2, 
                opacity: 0.8, 
                transparent: true 
            });
            
            // Draw Voronoi edges with optional coloring by PageRank score
            let edgeStats = null;
            let coloredCount = 0;
            let defaultCount = 0;
            
            // DEBUG: Are we even entering the edge drawing block?
            console.log('ðŸŽ¯ Edge Drawing Check:');
            console.log('  showVoronoiEdges =', showVoronoiEdges);
            console.log('  foam.voronoiEdges.length =', foam.voronoiEdges ? foam.voronoiEdges.length : 'undefined');
            
            if (showVoronoiEdges) {
                console.log(`\nðŸ” === EDGE DRAWING DEBUG ===`);
                console.log(`INSIDE EDGE BLOCK - Drawing ${foam.voronoiEdges.length} Voronoi edges`);
                console.log(`  colorEdgesByScore: ${colorEdgesByScore}`);
                console.log(`  lastEdgeScores: ${lastEdgeScores ? lastEdgeScores.size + ' scores' : 'null'}`);
                
                if (colorEdgesByScore && lastEdgeScores) {
                    edgeStats = { min: 1, max: 0, avg: 0, count: 0 };
                    console.log(`âœ… Edge coloring ENABLED with ${lastEdgeScores.size} scores`);
                    
                    // Sample some scores to verify they're different
                    const sampleKeys = Array.from(lastEdgeScores.keys()).slice(0, 5);
                    const sampleScores = sampleKeys.map(k => lastEdgeScores.get(k));
                    console.log('Sample scores:', sampleScores.map(s => s.toFixed(4)).join(', '));
                } else {
                    console.log('âŒ Edge coloring DISABLED or no scores available');
                    if (colorEdgesByScore) {
                        setStatus('No edge scores availableâ€”compute scores first.', false);
                    }
                }
                
                for (const edgePair of foam.voronoiEdges) {
                // edgePair is [tet1_idx, tet2_idx]
                const tet1Idx = edgePair[0];
                const tet2Idx = edgePair[1];
                const p1 = foam.centers[tet1Idx];
                const p2 = foam.centers[tet2Idx];
                
                if (!p1 || !p2) continue;
                
                const p2Final = foam.isPeriodic ? getMinimumImage(p1, p2) : p2;
                const lineGeom = new THREE.BufferGeometry().setFromPoints([ 
                    new THREE.Vector3(...p1), 
                    new THREE.Vector3(...p2Final) 
                ]);
                
                // Determine edge color
                let edgeMaterial;
                if (colorEdgesByScore && lastEdgeScores && lastEdgeScores.size > 0) {
                    const edgeKey = `${Math.min(tet1Idx, tet2Idx)}-${Math.max(tet1Idx, tet2Idx)}`;
                    const score = lastEdgeScores.get(edgeKey);
                    
                    if (score !== undefined) {
                        // Update stats
                        if (edgeStats) {
                            edgeStats.min = Math.min(edgeStats.min, score);
                            edgeStats.max = Math.max(edgeStats.max, score);
                            edgeStats.avg += score;
                            edgeStats.count++;
                        }
                        
                        const color = edgeScoreToColor(score);
                        
                        // Check if force rainbow test is enabled
                        const forceRainbow = document.getElementById('forceRainbowTest') && 
                                            document.getElementById('forceRainbowTest').checked;
                        
                        let finalColor;
                        if (forceRainbow) {
                            // FORCE TEST: Use rainbow colors to prove Three.js works
                            const testColors = [0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF];
                            finalColor = testColors[coloredCount % testColors.length];
                        } else {
                            // Use PageRank-based color
                            finalColor = color.getHex();
                        }
                        
                        edgeMaterial = new THREE.LineBasicMaterial({ 
                            color: finalColor,
                            linewidth: 3,
                            opacity: 1.0,
                            transparent: false
                        });
                        
                        // Detailed debug for ALL edges
                        if (coloredCount < 10 || coloredCount % 50 === 0) {
                            console.log(`ðŸŽ¨ Edge ${coloredCount} [${edgeKey}]:`);
                            console.log(`   Score: ${score.toFixed(4)}`);
                            if (forceRainbow) {
                                console.log(`   ðŸŒˆ FORCED COLOR: #${finalColor.toString(16).padStart(6, '0').toUpperCase()}`);
                            } else {
                                const hsl = {};
                                color.getHSL(hsl);
                                console.log(`   PageRank Color: #${finalColor.toString(16).padStart(6, '0').toUpperCase()}`);
                                console.log(`   HSL: h=${(hsl.h * 360).toFixed(0)}Â°, s=${(hsl.s * 100).toFixed(0)}%, l=${(hsl.l * 100).toFixed(0)}%`);
                            }
                            console.log(`   Material.color: #${edgeMaterial.color.getHex().toString(16).padStart(6, '0').toUpperCase()}`);
                        }
                        
                        coloredCount++;
                    } else {
                        // Edge not found in scores, use default
                        if (coloredCount === 0 && defaultCount === 0) {
                            console.warn(`Edge ${edgeKey} not found in scores`);
                        }
                        edgeMaterial = foam.isPeriodic ? defaultVoronoiPeriodicMaterial : defaultVoronoiMaterial;
                        defaultCount++;
                    }
                } else {
                    // Use default material when not coloring by score
                    edgeMaterial = foam.isPeriodic ? defaultVoronoiPeriodicMaterial : defaultVoronoiMaterial;
                    defaultCount++;
                }
                
                voronoiGroup.add(new THREE.Line(lineGeom, edgeMaterial));
                }
                
                // Display coloring summary and fallback diagnostics
                if (colorEdgesByScore && lastEdgeScores) {
                    console.log(`Edge coloring complete: ${coloredCount} colored, ${defaultCount} default`);
                    const total = coloredCount + defaultCount;
                    if (coloredCount === 0) {
                        console.error('WARNING: No edges were colored! Check edge key matching.');
                    }
                    if (total > 0) {
                        const fallbackPct = (defaultCount / total) * 100;
                        if (fallbackPct > 5) {
                            setStatus(`Some edges lacked scores (${fallbackPct.toFixed(1)}%). Check L/Î± (MC) or depth (PR).`, false);
                        }
                    }
                }
                
                // Display edge statistics
                if (showEdgeStats && edgeStats && edgeStats.count > 0) {
                    edgeStats.avg /= edgeStats.count;
                    const statsText = `Edge Stats: Min=${edgeStats.min.toFixed(3)}, Max=${edgeStats.max.toFixed(3)}, Avg=${edgeStats.avg.toFixed(3)}, Count=${edgeStats.count}`;
                    console.log(statsText);
                    setStatus(statsText, true);
                }
            } // End of if (showVoronoiEdges)

            // Draw Voronoi faces
            const maxPointsForFaces = 300;
            const showFaces = document.getElementById('showVoronoiFaces').checked;
            voronoiFacesGroup.visible = showFaces;
            
            // Only draw faces if checkbox is checked
            if (showFaces) {
            if (foam.numPoints > maxPointsForFaces) {
                console.log(`Skipping faces: points=${foam.numPoints} > ${maxPointsForFaces}`);
                return;
            }
            if (!foam.tetrahedra.length || !foam.barycenters.length) return;

            const cells = new Map();
            foam.tetrahedra.forEach((tet, index) => {
                const center = foam.barycenters[index];
                if (!center) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(new THREE.Vector3(...center));
                });
            });

            let built = 0;
            cells.forEach((cellVertices) => {
                if (cellVertices.length < 4) return;

                const ref = cellVertices[0];
                const adjusted = cellVertices.map(v => {
                    const out = v.clone();
                    if (!foam.isPeriodic) return out;
                    for (let k = 0; k < 3; k++) {
                        let diff = v.getComponent(k) - ref.getComponent(k);
                        if (diff > 0.5) out.setComponent(k, v.getComponent(k) - 1.0);
                        else if (diff < -0.5) out.setComponent(k, v.getComponent(k) + 1.0);
                    }
                    return out;
                });

                const geometry = new ConvexGeometry(adjusted);
                const mesh = new THREE.Mesh(geometry, voronoiFaceMaterial);
                voronoiFacesGroup.add(mesh);
                built++;
            });
            console.log(`Built ${built} Voronoi cell meshes`);
            } // End of if (showFaces)

            // Draw VoroX flow if enabled
            if (document.getElementById('showVoroX').checked) {
                const centers = foam.barycenters;
                const faceAdj = foam.getFaceAdjacency();
                const flow = buildVoroXFlow({ tetrahedra: foam.tetrahedra, centers, faceAdjacency: faceAdj });
                const colorByKnot = document.getElementById('voroxColorByScore').checked;
                const maxSegs = parseInt(document.getElementById('voroxMaxSegs').value);
                voroxFlowCache = flow;
                voroxCenters = centers;

                let drawn = 0;
                for (let ti = 0; ti < flow.activeEdges.length; ti++) {
                    for (let fi = 0; fi < 4; fi++) {
                        if (drawn >= maxSegs) break;
                        const nxt = flow.activeEdges[ti][fi];
                        if (!nxt) continue;
                        let c1 = centers[ti];
                        let c2 = centers[nxt.tet];
                        if (foam.isPeriodic) {
                            c2 = getMinimumImage(c1, c2);
                        }
                        // Knot-based coloring removed; always use picker or score elsewhere
                        const col = new THREE.Color(document.getElementById('voronoiEdgeColor').value || '#ff00aa');
                        const mat = new THREE.LineBasicMaterial({ color: col.getHex(), opacity: 0.9, transparent: true });
                        const g = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...c1), new THREE.Vector3(...c2)
                        ]);
                        voroxGroup.add(new THREE.Line(g, mat));
                        drawn++;
                    }
                }

                // Knot highlighting removed
                // Initialize tracers if animation is on
                if (document.getElementById('animateVoroXFlow').checked) {
                    initVoroxTracers(flow, centers);
                } else {
            clearVoroxTracers();
                }
            }
        }

        // --- VoroX v2 Main Logic ---
        async function recompute() {
            if (!Module) return;
            const periodic = document.getElementById('periodicMode').checked;
            const centering = document.getElementById('voronoiMethod').value || 'circumcenter';
            voroxInstance = await createVoroX({ Module, points: currentPoints, periodic, centering });
            scores = calculateScores(voroxInstance.getFoam());
            
            // Recompute edge scores if coloring is enabled
            if (document.getElementById('colorEdgesByScore').checked) {
                const foam = voroxInstance.getFoam();
                const depth = parseInt(document.getElementById('dynSearchDepthNum').value) || 15;
                console.log(`Recomputing edge scores after mesh change (depth=${depth})...`);
                const edgeResult = calculateEdgeScores(foam, depth, 0.85);
                lastEdgeScores = edgeResult.scores;
            }
            
            updateScene();
        }

        function updateScene() {
            if (!voroxInstance) return;
            const foam = voroxInstance.getFoam();
            // Background color
            const bgHex = document.getElementById('backgroundColor').value;
            if (bgHex) scene.background = new THREE.Color(bgHex);
            // Boundary toggle
            const showBoundary = document.getElementById('showBoundary').checked;
            boundaryGroup.visible = showBoundary;
            const axes = scene.getObjectByName('axesHelper'); if (axes) axes.visible = showBoundary;
            // Vertices
            verticesGroup.clear();
            if (document.getElementById('showVertices').checked) {
                drawVertices(foam.points);
                verticesGroup.visible = true;
            } else { verticesGroup.visible = false; }
            drawDelaunay(foam);
            drawVoronoiAndFlow(foam);
            createGhostCellTiling();
            const statsCore = document.getElementById('statsCore');
            if (statsCore) {
                const numLinks = foam.facetPairs.flat().filter(Boolean).length / 2; // Each pair is a link, counted twice.
                statsCore.textContent = `VoroX: ${foam.simplices.length} tets, ${numLinks} links, periodic:${foam.isPeriodic}`;
            }
                renderLegend();
            
            // Auto-compute edge scores if edge coloring is enabled
            if (document.getElementById('colorEdgesByScore').checked && (!lastEdgeScores || lastEdgeScores.size === 0)) {
                const depth = parseInt(document.getElementById('dynSearchDepthNum').value) || 15;
                console.log('Computing edge scores for coloring...');
                try {
                    const edgeResult = calculateEdgeScores(foam, depth, 0.85);
                    lastEdgeScores = edgeResult.scores;
                    console.log(`Computed ${lastEdgeScores.size} edge scores for visualization`);
                    
                    // Show score statistics if "Show Edge Stats" is enabled
                    if (lastEdgeScores.size > 0) {
                        const values = Array.from(lastEdgeScores.values());
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        const avg = values.reduce((a,b) => a+b, 0) / values.length;
                        console.log(`Edge score range: min=${min.toFixed(4)}, max=${max.toFixed(4)}, avg=${avg.toFixed(4)}`);
                        
                        // Debug: show first few scores
                        const entries = Array.from(lastEdgeScores.entries()).slice(0, 5);
                        console.log('Sample scores:', entries);
                    }
                    
                    // Trigger redraw with scores
                    setTimeout(() => drawVoronoiAndFlow(foam), 100);
                } catch (error) {
                    console.error('Error computing edge scores:', error);
                }
            }
        }
        
        // Centralized dynamics options getter (moved above step for scope/ordering)
        function getDynamicsOptions() {
            return {
                edgeScale: document.getElementById('dynEdgeScale').checked,
                scale: parseFloat(document.getElementById('dynScaleNum').value),
                energy: parseFloat(document.getElementById('dynEnergyNum').value),
                equilibration: document.getElementById('dynEquilibration').checked,
                contractive: document.getElementById('dynContractive').checked,
                expansive: document.getElementById('dynExpansive').checked,
                recomputeEvery: 5,
                threshold: parseFloat(document.getElementById('dynThresholdNum').value) || 0.5,
                useEdgeMode: document.getElementById('dynUseEdgeMode').checked,
                useVerlet: document.getElementById('dynUseVerlet').checked,
                damping: parseFloat(document.getElementById('dynDampingNum').value) || 0.99
            };
        }
        // TEMP: expose for console validation; remove after verifying
        window.getDynamicsOptions = getDynamicsOptions;

        function step() {
            if (!voroxInstance) return;
            const dt = parseNumInput('dynDt', 0.02);
            const opts = getDynamicsOptions();
            const depth = parseInt(document.getElementById('dynSearchDepthNum').value);
            const foam = voroxInstance.getFoam();
            
            // Use edge-based or tetrahedra-based scoring
            if (opts.useEdgeMode) {
                // Edge-based PageRank scoring
                const edgeResult = calculateEdgeScores(foam, depth, 0.85);
                lastEdgeScores = edgeResult.scores;
                
                // Adapter owns integration; pass options (with edge scores)
                const stepOptions = {
                    ...opts,
                    useEdgeMode: true,
                    edgeScores: lastEdgeScores,
                    edge_scale: opts.edgeScale
                };
                voroxInstance.step(dt, stepOptions, null);
            } else {
                // Legacy tetrahedra-based scoring; adapter integrates
                scores = calculateScores(foam, depth);
                voroxInstance.step(dt, opts, scores);
            }
            
            updateScene();
        }
        
        // Initialize everything
        window.PeriodicDelaunayModule().then(async module => {
            Module = module;
            setStatus('Module loaded');
            
            initThree();
            
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const minDist = parseFloat(document.getElementById('minDistance').value);
            currentPoints = generatePoissonPoints(numPoints, minDist);
            
            await recompute();
            
            document.getElementById('regenerate').addEventListener('click', async () => {
                const numPoints = parseInt(document.getElementById('numPoints').value);
                const minDist = parseFloat(document.getElementById('minDistance').value);
                currentPoints = generatePoissonPoints(numPoints, minDist);
                await recompute();
            });

            const recomputeBtn = document.getElementById('recompute');
            if (recomputeBtn) {
                recomputeBtn.addEventListener('click', async () => {
                    await recompute();
                });
            }
            // Voronoi method change triggers rebuild
            const methodSel = document.getElementById('voronoiMethod');
            methodSel.addEventListener('change', async () => { await recompute(); });

            // Test-style controls wiring
            document.getElementById('resampleBtn').addEventListener('click', async () => {
                const N = parseInt(document.getElementById('numPoints').value) || 200;
                const minDist = parseFloat(document.getElementById('minDistance').value) || 0.05;
                currentPoints = generatePoissonPoints(N, minDist);
                await recompute();
            });
            document.getElementById('stepBtn').addEventListener('click', () => step());
            
            // Manual edge score computation button
            // Simple overlay for long-running computes (module-scope variable)
            overlayEl = document.getElementById('computeOverlay');
            if (!overlayEl) {
                overlayEl = document.createElement('div');
                overlayEl.id = 'computeOverlay';
                overlayEl.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);color:#fff;display:none;align-items:center;justify-content:center;z-index:9999;font:14px/1.4 system-ui;';
                overlayEl.innerHTML = '<div style="background:#222;padding:12px 16px;border-radius:6px;">Computing edge scoresâ€¦ <span class="spinner" style="display:inline-block;width:12px;height:12px;border:2px solid #999;border-top-color:#fff;border-radius:50%;margin-left:8px;animation:spin 0.8s linear infinite;"></span></div>';
                const style = document.createElement('style');
                style.textContent = '@keyframes spin{to{transform:rotate(360deg)}}';
                document.head.appendChild(style);
                document.body.appendChild(overlayEl);
            }

            // Initialize Brain worker (optional)
            try {
                brainWorker = new Worker('../../src/js/workers/brain.worker.js', { type: 'module' });
                brainWorker.onmessage = (ev) => {
                    const { foamHash, method, params, runtimeMs, scores, stats } = ev.data || {};
                    const sig = `${foamHash}|${method}|${JSON.stringify(params)}`;
                    if (!pendingSig || sig !== pendingSig) return; // stale response
                    const map = new Map();
                    if (scores && scores.keys && scores.values) {
                        for (let i = 0; i < scores.keys.length; i++) {
                            map.set(String(scores.keys[i]), Number(scores.values[i]));
                        }
                    }
                    lastEdgeScores = map;
                    lastBrainSig = pendingSig;
                    brainInFlight = false;
                    pendingSig = null;
                    brainLastTimeMs = performance.now();
                    physStepsSinceBrain = 0;
                    overlayEl.style.display = 'none';
                    setStatus(`Brain ${runtimeMs?.toFixed ? runtimeMs.toFixed(1) : runtimeMs} ms â€” bins ${map.size}${stats?`, var ${Number(stats.variance||0).toFixed(4)}`:''}`, true);
                    renderLegend();
                };
                brainWorker.onerror = () => {
                    // Clear flight state and hide overlay
                    brainInFlight = false; pendingSig = null; if (overlayEl) overlayEl.style.display = 'none';
                    setStatus('Brain worker error; falling back to main thread', false);
                    try {
                        if (!voroxInstance) return;
                        const foam = voroxInstance.getFoam();
                        const useMC = document.getElementById('scoreModeMC').checked;
                        const paramsNow = useMC
                            ? { L: Math.max(2, Math.min(32, parseInt(document.getElementById('mcStepsL').value || 12))), K: Math.round(Math.max(8, Math.min(256, parseInt(document.getElementById('mcWalkersK').value || 64)))/8)*8, alpha: Math.max(0.75, Math.min(0.98, parseFloat((document.getElementById('mcAlpha').value || '0.90').toString().replace(',', '.')))) }
                            : { depth: parseInt(document.getElementById('dynSearchDepthNum').value) || 15, damping: 0.85 };
                        const methodNow = useMC ? 'mc' : 'pagerank';
                        const foamHash = (typeof buildFoamHash === 'function') ? buildFoamHash(foam) : 0;
                        const sig = `${foamHash}|${methodNow}|${JSON.stringify(paramsNow)}`;
                        let edgeResult;
                        if (useMC) {
                            const { L, K, alpha } = paramsNow;
                            edgeResult = calculateEdgeScoresMonteCarlo(foam, L, K, alpha);
                            lastScoreMethod = 'mc'; lastScoreParams = { L, K, alpha };
                        } else {
                            const { depth, damping } = paramsNow;
                            edgeResult = calculateEdgeScores(foam, depth, damping);
                            lastScoreMethod = 'pagerank'; lastScoreParams = { depth, damping };
                        }
                        lastEdgeScores = edgeResult.scores;
                        lastBrainSig = sig; brainLastTimeMs = performance.now(); physStepsSinceBrain = 0;
                        renderLegend();
                        setStatus('Brain fallback computed on main thread', true);
                    } catch (e) {
                        console.error('Brain fallback failed:', e);
                    }
                };
            } catch (e) {
                console.warn('Brain worker not available:', e);
                brainWorker = null;
            }

            // Cache helpers
            function crc32(str){let c=~0;for(let i=0;i<str.length;i++){c=(c>>>8)^table[(c^str.charCodeAt(i))&0xff]}return ~c>>>0}const table=new Uint32Array(256).map((_,n)=>{let c=n;for(let k=0;k<8;k++)c=c&1?0xEDB88320^(c>>>1):c>>>1;return c});
            function buildFoamHash(foam){
                const periodic = foam.isPeriodic ? 1 : 0;
                const centering = (document.getElementById('voronoiMethod')?.value || 'circumcenter');
                const np = foam.points.length;
                const nt = foam.simplices.length;
                const ve = foam.voronoiEdges?.length || 0;
                const keys = [];
                if (foam.voronoiEdges) {
                    const N = Math.min(2048, foam.voronoiEdges.length);
                    for (let i=0;i<N;i++){
                        const [a,b] = foam.voronoiEdges[i];
                        keys.push(a<b?`${a}-${b}`:`${b}-${a}`);
                    }
                }
                const sig = `${periodic}|${centering}|${np}|${nt}|${ve}|${keys.join(',')}`;
                return crc32(sig);
            }

            let autoTimeout = null;

            document.getElementById('computeEdgeScoresBtn').addEventListener('click', () => {
                if (!voroxInstance) {
                    console.log('No VoroX instance available');
                    return;
                }
                const foam = voroxInstance.getFoam();
                const useMC = document.getElementById('scoreModeMC').checked;
                const foamHash = buildFoamHash(foam);

                // Skip if up to date
                const paramsNow = useMC
                    ? { L: Math.max(2, Math.min(32, parseInt(document.getElementById('mcStepsL').value || 12))), K: Math.round(Math.max(8, Math.min(256, parseInt(document.getElementById('mcWalkersK').value || 64)))/8)*8, alpha: Math.max(0.75, Math.min(0.98, parseFloat((document.getElementById('mcAlpha').value || '0.90').toString().replace(',', '.')))) }
                    : { depth: parseInt(document.getElementById('dynSearchDepthNum').value) || 15, damping: 0.85 };
                const methodNow = useMC ? 'mc' : 'pagerank';
                if (lastEdgeScores && lastEdgeScores.size>0 && lastScoreMethod===methodNow && JSON.stringify(lastScoreParams)===JSON.stringify(paramsNow) && lastFoamHash===foamHash){
                    setStatus('Scores up to date.', true);
                    return;
                }

                // MC cost estimate and warning
                if (useMC) {
                    const L = paramsNow.L, K = paramsNow.K, E = foam.voronoiEdges?.length || 0;
                    const est = 2 * E * K * L;
                    if (est > 25_000_000) {
                        const suggested = Math.max(8, Math.floor(10_000_000 / Math.max(1, 2*E*L)/8)*8);
                        const proceed = confirm(`High cost (â‰ˆ${Math.round(est/1e6)}M steps). Reduce K to ${suggested}? Click Cancel to keep current and proceed.`);
                        if (proceed) {
                            document.getElementById('mcWalkersK').value = suggested;
                            paramsNow.K = suggested;
                        }
                    } else if (est > 10_000_000) {
                        setStatus(`High cost warning (â‰ˆ${Math.round(est/1e6)}M steps). Consider reducing K.`, false);
                    }
                }

                overlayEl.style.display = 'flex';
                let edgeResult;
                if (useMC) {
                    const { L, K, alpha } = paramsNow;
                    console.log(`Manual edge score computation (MC): L=${L}, K=${K}, alpha=${alpha}...`);
                    edgeResult = calculateEdgeScoresMonteCarlo(foam, L, K, alpha);
                    lastScoreMethod = 'mc';
                    lastScoreParams = { L, K, alpha };
                } else {
                    const { depth } = paramsNow;
                    console.log(`Manual edge score computation (PR): depth=${depth}...`);
                    edgeResult = calculateEdgeScores(foam, depth, 0.85);
                    lastScoreMethod = 'pagerank';
                    lastScoreParams = { depth, damping: 0.85 };
                }
                lastEdgeScores = edgeResult.scores;
                lastScoreTimestamp = Date.now();
                lastFoamHash = foamHash;
                console.log(`Computed ${lastEdgeScores.size} edge scores`);
                
                // Debug: Check if keys match
                if (foam.voronoiEdges && foam.voronoiEdges.length > 0) {
                    const testEdge = foam.voronoiEdges[0];
                    const testKey = `${Math.min(testEdge[0], testEdge[1])}-${Math.max(testEdge[0], testEdge[1])}`;
                    console.log('Test edge from foam:', testEdge, 'â†’ key:', testKey);
                    console.log('Has score?', lastEdgeScores.has(testKey));
                    console.log('First 3 score keys:', Array.from(lastEdgeScores.keys()).slice(0, 3));
                }
                
                // Show statistics
                if (lastEdgeScores && lastEdgeScores.size > 0) {
                    const values = Array.from(lastEdgeScores.values());
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const avg = values.reduce((a,b) => a+b, 0) / values.length;
                    const statsText = `Edge Scores: min=${min.toFixed(3)}, max=${max.toFixed(3)}, avg=${avg.toFixed(3)}, count=${lastEdgeScores.size}`;
                    console.log(statsText);
                    setStatus(statsText, true);
                    if (max - min < 1e-3) {
                        setStatus('Low score variance; try increasing L or decreasing Î± (MC), or depth (PR)', false);
                    }
                } else {
                    setStatus('No obtuse connectivity within horizon; increase L or Î±', false);
                }
                
                overlayEl.style.display = 'none';
                updateScene();
                renderLegend();
            });
            
            // Quick Color Demo button
            document.getElementById('quickColorBtn').addEventListener('click', async () => {
                console.log('ðŸŒˆ Quick Color Demo: Setting up edge coloring...');
                
                // 1. Generate fewer, irregular points for better variation
                document.getElementById('numPoints').value = 30;
                currentPoints = [];
                for (let i = 0; i < 30; i++) {
                    currentPoints.push([
                        Math.random() * 0.7 + 0.15,
                        Math.random() * 0.7 + 0.15,
                        Math.random() * 0.7 + 0.15
                    ]);
                }
                
                // 2. Recompute with new points
                await recompute();
                
                // 3. Set Search Depth to high value
                document.getElementById('dynSearchDepth').value = 25;
                document.getElementById('dynSearchDepthNum').value = 25;
                
                // 4. Enable edge display
                document.getElementById('showVoronoiEdgesToggle').checked = true;
                
                // 5. Compute edge scores
                const foam = voroxInstance.getFoam();
                const edgeResult = calculateEdgeScores(foam, 25, 0.85);
                lastEdgeScores = edgeResult.scores;
                
                // 6. Enable edge coloring
                document.getElementById('colorEdgesByScore').checked = true;
                document.getElementById('showEdgeStats').checked = true;
                
                // 7. Show statistics
                if (lastEdgeScores.size > 0) {
                    const values = Array.from(lastEdgeScores.values());
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const avg = values.reduce((a,b) => a+b, 0) / values.length;
                    const range = max - min;
                    console.log('ðŸŒˆ Edge coloring ready!');
                    console.log(`  Score range: ${min.toFixed(3)} to ${max.toFixed(3)} (range: ${range.toFixed(3)})`);
                    console.log(`  Expected colors: Red (low) â†’ Yellow (mid) â†’ Green (high)`);
                    setStatus(`ðŸŒˆ Edge coloring active! Range: ${range.toFixed(3)}`, true);
                }
                
                // 8. Update display
                updateScene();
                renderLegend();
            });
            
            const runBtn = document.getElementById('runBtn');
            let runOn = false;

            // Function to sync slider and number input
            function setupSliderSync(sliderId, numberId) {
                const slider = document.getElementById(sliderId);
                const numberInput = document.getElementById(numberId);
                slider.addEventListener('input', () => numberInput.value = slider.value);
                numberInput.addEventListener('input', () => slider.value = numberInput.value);
            }

            // Sync all the new sliders
            // Special handling for Search Depth to recompute scores
            const depthSlider = document.getElementById('dynSearchDepth');
            const depthNumber = document.getElementById('dynSearchDepthNum');
            depthSlider.addEventListener('input', () => {
                depthNumber.value = depthSlider.value;
                // Recompute edge scores if coloring is enabled
                if (document.getElementById('colorEdgesByScore').checked && voroxInstance) {
                    const foam = voroxInstance.getFoam();
                    const depth = parseInt(depthSlider.value);
                    console.log(`Recomputing edge scores with new depth: ${depth}`);
                    const edgeResult = calculateEdgeScores(foam, depth, 0.85);
                    lastEdgeScores = edgeResult.scores;
                    // Show statistics
                    if (lastEdgeScores.size > 0) {
                        const values = Array.from(lastEdgeScores.values());
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        console.log(`New score range: ${min.toFixed(3)} to ${max.toFixed(3)}`);
                    }
                    updateScene();
                }
            });
            depthNumber.addEventListener('input', () => {
                depthSlider.value = depthNumber.value;
                // Recompute edge scores if coloring is enabled
                if (document.getElementById('colorEdgesByScore').checked && voroxInstance) {
                    const foam = voroxInstance.getFoam();
                    const depth = parseInt(depthNumber.value);
                    console.log(`Recomputing edge scores with new depth: ${depth}`);
                    const edgeResult = calculateEdgeScores(foam, depth, 0.85);
                    lastEdgeScores = edgeResult.scores;
                    // Show statistics
                    if (lastEdgeScores.size > 0) {
                        const values = Array.from(lastEdgeScores.values());
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        console.log(`New score range: ${min.toFixed(3)} to ${max.toFixed(3)}`);
                    }
                    updateScene();
                }
            });
            
            setupSliderSync('dynFPS', 'dynFPSNum');
            setupSliderSync('dynThreshold', 'dynThresholdNum');
            setupSliderSync('dynDecay', 'dynDecayNum');
            setupSliderSync('dynDt', 'dynDtNum');
            setupSliderSync('dynEnergy', 'dynEnergyNum');
            setupSliderSync('dynScale', 'dynScaleNum');
            setupSliderSync('dynDamping', 'dynDampingNum');
            setupSliderSync('voroxMaxSegs', 'voroxMaxSegsNum');
            
            let frameCounter = 0;
            let lastTickTime = performance.now();

            function tick() {
                if (!runOn) return;

                const maxFramesEl = document.getElementById('dynMaxFramesNum');
                const maxFrames = maxFramesEl ? parseInt(maxFramesEl.value) : 0; // default 0 = no limit
                if (maxFrames > 0 && frameCounter >= maxFrames) {
                    runOn = false;
                    runBtn.style.backgroundColor = '';
                    runBtn.textContent = 'Run';
                    frameCounter = 0;
                    return;
                }

                rafId = requestAnimationFrame(tick);
                
                const now = performance.now();
                const delta = now - lastTickTime;
                const fpsLimit = parseInt(document.getElementById('dynFPSNum').value);
                const frameInterval = 1000 / fpsLimit;

                if (delta < frameInterval) {
                    return;
                }
                lastTickTime = now - (delta % frameInterval);

                // --- Two-Phase Brain/Physical Loop ---
                const dt = parseFloat(document.getElementById('dynDtNum').value);
                const options = getDynamicsOptions();
                const depth = parseInt(document.getElementById('dynSearchDepthNum').value);
                const physPerBrain = Math.max(1, Math.min(50, parseInt(document.getElementById('physPerBrain')?.value || '10')));
                const brainCooldownMs = Math.max(0, parseInt(document.getElementById('brainCooldownMs')?.value || '0'));

                let g = null; // gradient from physical step (for flow accumulation)

                if (document.getElementById('dynUseEdgeMode').checked) {
                    // Edge mode with cadence
                    const nowMs = performance.now();
                    const canBrain = (brainCooldownMs === 0) || ((nowMs - brainLastTimeMs) >= brainCooldownMs);
                    if (physStepsSinceBrain < physPerBrain || !canBrain) {
                        // Physical step (XPBD enabled)
                        const stepOptions = {
                            ...options,
                            useEdgeMode: true,
                            useXPBD: true,
                            edgeScores: lastEdgeScores,
                            edge_scale: options.edgeScale,
                            xpbdMaxScale: Math.max(0, Math.min(0.5, parseFloat(document.getElementById('xpbdMaxScale')?.value || '0.08'))),
                            xpbdInvert: !!document.getElementById('xpbdInvert')?.checked
                        };
                        // Inject refined XPBD controls
                        stepOptions.xpbdStrength = Math.max(0, Math.min(1, parseFloat(document.getElementById('xpbdStrength')?.value || '0.05')));
                        stepOptions.xpbdGamma = Math.max(0.25, Math.min(3, parseFloat(document.getElementById('xpbdGamma')?.value || '1.0')));
                        // Temporarily control retriangulation cadence for stability testing
                        stepOptions.recomputeEvery = Math.max(1, Math.min(10000, parseInt(document.getElementById('retriEvery')?.value || '999')));
                        if (!lastEdgeScores || lastEdgeScores.size === 0) {
                            setStatus('Waiting for Brain scoresâ€¦ running equilibration only', true);
                        }
                        g = voroxInstance.step(dt, stepOptions, null);
                        physStepsSinceBrain++;
                        runPhase = 'physical';
                    } else {
                        // Brain slot â€” worker-first logic
                        try {
                            // Gate after topology changes: prime caches on Brain, skip XPBD frame
                            if (typeof voroxInstance.shouldPrimeOnBrain === 'function' && voroxInstance.shouldPrimeOnBrain()) {
                                try { if (typeof voroxInstance.primeDualCaches === 'function') voroxInstance.primeDualCaches(); } catch {}
                                try { if (typeof voroxInstance.clearPrimeOnBrain === 'function') voroxInstance.clearPrimeOnBrain(); } catch {}
                            }
                            const foam = voroxInstance.getFoam();
                            const foamHash = (typeof buildFoamHash === 'function') ? buildFoamHash(foam) : 0;
                            const useMC = document.getElementById('scoreModeMC').checked;
                            const paramsNow = useMC
                                ? { L: Math.max(2, Math.min(32, parseInt(document.getElementById('mcStepsL').value || 12))), K: Math.round(Math.max(8, Math.min(256, parseInt(document.getElementById('mcWalkersK').value || 64)))/8)*8, alpha: Math.max(0.75, Math.min(0.98, parseFloat((document.getElementById('mcAlpha').value || '0.90').toString().replace(',', '.')))) }
                                : { depth, damping: 0.85 };
                            const methodNow = useMC ? 'mc' : 'pagerank';
                            const sSig = `${foamHash}|${methodNow}|${JSON.stringify(paramsNow)}`;

                            // Skip if unchanged and we have scores
                            if (lastEdgeScores && lastEdgeScores.size > 0 && lastBrainSig === sSig) {
                                setStatus('Brain (skipped) â€” scores up to date', true);
                                physStepsSinceBrain = 0; brainLastTimeMs = nowMs; runPhase = 'brain'; renderLegend();
                                return;
                            }

                            // If no worker, do a single main-thread fallback
                            if (!brainWorker) {
                                let edgeResult;
                                if (useMC) {
                                    const { L, K, alpha } = paramsNow;
                                    edgeResult = calculateEdgeScoresMonteCarlo(foam, L, K, alpha);
                                    lastScoreMethod = 'mc'; lastScoreParams = { L, K, alpha };
                                } else {
                                    const { depth: d, damping } = paramsNow;
                                    edgeResult = calculateEdgeScores(foam, d, damping);
                                    lastScoreMethod = 'pagerank'; lastScoreParams = { depth: d, damping };
                                }
                                lastEdgeScores = edgeResult.scores;
                                lastBrainSig = sSig; brainLastTimeMs = performance.now(); physStepsSinceBrain = 0; runPhase = 'brain';
                                renderLegend();
                                setStatus('Brain fallback computed on main thread', true);
                                return;
                            }

                            // Build transferable-friendly foam data
                            const foamData = {
                                points: foam.points,
                                simplices: foam.simplices,
                                centers: foam.centers,
                                facetPairs: foam.facetPairs,
                                voronoiEdges: foam.voronoiEdges,
                                isPeriodic: !!foam.isPeriodic,
                            };

                            if (brainInFlight) {
                                if (pendingSig === sSig) {
                                    setStatus('Brain (in-flight)', true);
                                    return;
                                } else {
                                    pendingSig = sSig;
                                    if (overlayEl) overlayEl.style.display = 'flex';
                                    brainWorker.postMessage({ foamHash, method: methodNow, params: paramsNow, foamData });
                                    setStatus('Brain (queued new request)', true);
                                    return;
                                }
                            } else {
                                brainInFlight = true;
                                pendingSig = sSig;
                                if (overlayEl) overlayEl.style.display = 'flex';
                                brainWorker.postMessage({ foamHash, method: methodNow, params: paramsNow, foamData });
                                setStatus('Brain (started)', true);
                                return;
                            }
                        } catch (e) {
                            console.error('Brain slot error:', e);
                            setStatus('Brain slot error; continuing physical', false);
                            const stepOptions2 = { ...options, useEdgeMode: true, useXPBD: true, edgeScores: lastEdgeScores, edge_scale: options.edgeScale, xpbdMaxScale: Math.max(0, Math.min(0.5, parseFloat(document.getElementById('xpbdMaxScale')?.value || '0.10'))) };
                            g = voroxInstance.step(dt, stepOptions2, null);
                            physStepsSinceBrain++;
                            runPhase = 'physical';
                        }
                    }
                } else {
                    // Legacy (tet-based); keep behavior
                    scores = calculateScores(voroxInstance.getFoam(), depth);
                    g = voroxInstance.step(dt, options, scores);
                    runPhase = 'physical';
                }
                
                // --- Decay and Accumulate Flow (only when we have a gradient) ---
                if (g) {
                    const decayFactor = parseFloat(document.getElementById('dynDecayNum').value);
                    let currentFlow = voroxInstance.getFlow();
                    const numTets = voroxInstance.getFoam().simplices.length;
                    if (currentFlow.length !== numTets) {
                        currentFlow = Array.from({length: numTets}, ()=>Array(4).fill(0.0));
                    }
                    for (let i=0; i<currentFlow.length; i++) {
                        for (let j=0; j<4; j++) {
                            currentFlow[i][j] *= decayFactor;
                        }
                    }
                    for (let i=0; i<g.length; i++) {
                        const norm = Math.hypot(g[i][0], g[i][1], g[i][2]);
                        const tet = voroxInstance.getFoam().simplices.find(t => t.includes(i));
                        if (tet) {
                            const tetIdx = voroxInstance.getFoam().simplices.indexOf(tet);
                            if (tetIdx > -1 && tetIdx < currentFlow.length) {
                               for (let j=0; j<4; j++) currentFlow[tetIdx][j] += norm * 0.25;
                            }
                        }
                    }
                    voroxInstance.setFlow(currentFlow);
                }

                updateScene();
                if (runPhase === 'physical' && document.getElementById('dynUseEdgeMode').checked) {
                    const n = Math.max(1, Math.min(50, parseInt(document.getElementById('physPerBrain')?.value || '5')));
                    const stats = (typeof voroxInstance.getLastStepStats === 'function') ? voroxInstance.getLastStepStats() : null;
                    if (stats) {
                        const msg = `Physical ${physStepsSinceBrain}/${n} â€” faces: ${stats.affectedFaces}, mean Î”: ${stats.meanDelta.toFixed(4)}, max Î”: ${stats.maxDelta.toFixed(4)}`;
                        setStatus(msg, true);
                    } else {
                        setStatus(`Physical ${physStepsSinceBrain}/${n}`, true);
                    }
                }
                frameCounter++;
                runBtn.textContent = `Stop (${frameCounter})`;
            }
            
            runBtn.addEventListener('click', () => {
                runOn = !runOn;
                if (runOn) {
                    frameCounter = 0;
                    lastTickTime = performance.now();
                    runBtn.style.backgroundColor = '#dc3545';
                    runBtn.textContent = 'Stop';
                    // On run start: reset cadence and force initial Brain in edge mode
                    physStepsSinceBrain = 0;
                    if (document.getElementById('dynUseEdgeMode').checked && voroxInstance) {
                        try {
                            const foam = voroxInstance.getFoam();
                            let edgeResult;
                            if (document.getElementById('scoreModeMC').checked) {
                                const L = Math.max(2, Math.min(32, parseInt(document.getElementById('mcStepsL').value || '12')));
                                let K = Math.max(8, Math.min(256, parseInt(document.getElementById('mcWalkersK').value || '64')));
                                K = Math.round(K/8)*8;
                                const alpha = Math.max(0.75, Math.min(0.98, parseFloat((document.getElementById('mcAlpha').value || '0.90').toString().replace(',', '.'))));
                                edgeResult = calculateEdgeScoresMonteCarlo(foam, L, K, alpha);
                                lastScoreMethod = 'mc';
                                lastScoreParams = { L, K, alpha };
                            } else {
                                const depthNow = parseInt(document.getElementById('dynSearchDepthNum').value) || 15;
                                edgeResult = calculateEdgeScores(foam, depthNow, 0.85);
                                lastScoreMethod = 'pagerank';
                                lastScoreParams = { depth: depthNow, damping: 0.85 };
                            }
                            lastEdgeScores = edgeResult.scores;
                            lastScoreTimestamp = Date.now();
                            try { if (typeof buildFoamHash === 'function') { lastFoamHash = buildFoamHash(foam); } } catch {}
                            brainLastTimeMs = performance.now();
                            renderLegend();
                            setStatus(`Brain initialized (${lastEdgeScores?.size||0} edges)`, true);
                        } catch (e) {
                            console.error('Initial Brain compute failed:', e);
                            setStatus('Initial Brain compute failed; will proceed with equilibration', false);
                        }
                    }
                    tick();
                } else {
                    cancelAnimationFrame(rafId);
                    runBtn.style.backgroundColor = '';
                    runBtn.textContent = 'Run';
                    frameCounter = 0;
                }
            });
            
            // animateChk.addEventListener('change', () => {
            //     if (animateChk.checked) {
            //         cancelAnimationFrame(rafId);
            //         tick();
            //     } else {
            //         cancelAnimationFrame(rafId);
            //     }
            // });

            document.getElementById('periodicMode').addEventListener('change', async () => {
                if (voroxInstance) {
                    voroxInstance.setPeriodic(document.getElementById('periodicMode').checked);
                    // sync Flow-periodic checkbox if present
                    const dp = document.getElementById('dynPeriodic'); if (dp) dp.checked = document.getElementById('periodicMode').checked;
                    updateScene();
                }
            });
            // Flow dynamics Periodic toggle (syncs with top)
            const dynPeriodic = document.createElement('input');
            dynPeriodic.type = 'checkbox';
            dynPeriodic.id = 'dynPeriodic';
            dynPeriodic.style.display = 'none'; // logical control only
            document.body.appendChild(dynPeriodic);
            dynPeriodic.addEventListener('change', async () => {
                const val = dynPeriodic.checked;
                const top = document.getElementById('periodicMode');
                top.checked = val;
                if (voroxInstance) {
                    voroxInstance.setPeriodic(val);
                    updateScene();
                }
            });

            // Re-render on toggles that affect visibility/coloring
                const rerenderIds = [
                'showVertices','showDelaunay','showTetrahedra','showVoronoi','showVoronoiEdgesToggle','showVoronoiFaces',
                'showVoroX','showGhostCells','voroxColorByScore','flowColorByScore','voroxMaxSegs','voronoiSize','voronoiVertexColor','showBoundary',
                'backgroundColor','colorEdgesByScore','showEdgeStats','forceRainbowTest','scoreModePR','scoreModeMC','mcStepsL','mcWalkersK','mcAlpha','mcAutoRecompute','colorSteps','colorPalette','quantization','reversePalette'
            ];
            // Initialize scoring UI visibility (no recompute here)
            const prBlock = document.getElementById('prParamsBlock');
            const mcBlock = document.getElementById('mcParamsBlock');
            function updateModeVisibility() {
                const useMC = document.getElementById('scoreModeMC').checked;
                if (useMC) { prBlock.style.display = 'none'; mcBlock.style.display = ''; }
                else { prBlock.style.display = ''; mcBlock.style.display = 'none'; }
            }
            updateModeVisibility();
            ['scoreModePR','scoreModeMC'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('change', () => { updateModeVisibility(); setStatus('Scoring mode switched.', true); if (document.getElementById('mcAutoRecompute').checked) scheduleAutoRecompute(); });
            });

            rerenderIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('change', () => {
                    // Enforce parameter ranges for MC inputs
                    if (id === 'mcStepsL') {
                        let v = parseInt(el.value || 12, 10); if (v < 2) v = 2; if (v > 32) v = 32; el.value = v;
                        setStatus(`Adjusted parameter L to ${v} (valid 2â€“32)`, true);
                        if (document.getElementById('mcAutoRecompute').checked) scheduleAutoRecompute();
                    } else if (id === 'mcWalkersK') {
                        let v = parseInt(el.value || 64, 10); if (v < 8) v = 8; if (v > 256) v = 256; v = Math.round(v/8)*8; el.value = v;
                        setStatus(`Adjusted parameter K to ${v} (valid 8â€“256)`, true);
                        if (document.getElementById('mcAutoRecompute').checked) scheduleAutoRecompute();
                    } else if (id === 'mcAlpha') {
                        let v = parseFloat((el.value || '0.90').toString().replace(',', '.')); if (v < 0.75) v = 0.75; if (v > 0.98) v = 0.98; v = Math.round(v*100)/100; el.value = v.toFixed(2);
                        setStatus(`Adjusted parameter Î± to ${el.value} (valid 0.75â€“0.98)`, true);
                        if (document.getElementById('mcAutoRecompute').checked) scheduleAutoRecompute();
                    }
                    // Capture color mapping UI state (no recompute here; used during draw)
                    if (id === 'colorSteps' || id === 'colorPalette' || id === 'quantization' || id === 'reversePalette') {
                        colorSteps = Math.max(2, Math.min(10, parseInt(document.getElementById('colorSteps').value || 5)));
                        paletteId = document.getElementById('colorPalette').value || 'seq_ryg';
                        quantization = document.getElementById('quantization').value || 'equal';
                        reversePalette = !!document.getElementById('reversePalette').checked;
                        cachedThresholds = null; cachedStepColors = null; cachedScoreHash = null; // invalidate cache
                    }
                    // If edge coloring is enabled, compute scores immediately
                    if (id === 'colorEdgesByScore' && el.checked && voroxInstance) {
                        const foam = voroxInstance.getFoam();
                        const depth = parseInt(document.getElementById('dynSearchDepthNum').value) || 15;
                        console.log(`Computing edge scores for coloring with depth=${depth}...`);
                        const edgeResult = calculateEdgeScores(foam, depth, 0.85);
                        lastEdgeScores = edgeResult.scores;
                        console.log(`Computed ${lastEdgeScores.size} scores`);
                        
                        // Debug output with detailed stats
                        if (lastEdgeScores.size > 0) {
                            const values = Array.from(lastEdgeScores.values());
                            const min = Math.min(...values);
                            const max = Math.max(...values);
                            const avg = values.reduce((a,b) => a+b, 0) / values.length;
                            console.log(`Score statistics:`);
                            console.log(`  Min: ${min.toFixed(4)}`);
                            console.log(`  Max: ${max.toFixed(4)}`);
                            console.log(`  Avg: ${avg.toFixed(4)}`);
                            console.log(`  Range: ${(max - min).toFixed(4)}`);
                            
                            // Warn if scores are too similar
                            if (max - min < 0.1) {
                                console.warn('âš ï¸ Low score variance! Try increasing Search Depth or using fewer/irregular points.');
                            }
                        }
                        
                        // Make sure edges are visible
                        if (!document.getElementById('showVoronoiEdgesToggle').checked) {
                            document.getElementById('showVoronoiEdgesToggle').checked = true;
                            console.log('Enabled Voronoi edges display');
                        }
                    } else if (id === 'colorEdgesByScore' && !el.checked) {
                        // Clear scores when unchecked
                        console.log('Clearing edge scores');
                        lastEdgeScores = null;
                    }
                    updateScene();
                    renderLegend();
                });
            });

            // Hide/show Verlet controls based on XPBD usage
            function updateVerletVisibility() {
                const useXPBD = !!document.getElementById('dynUseEdgeMode').checked; // XPBD only in edge mode
                const verletRow = document.getElementById('dynDamping')?.closest('.control-group');
                const verletChk = document.getElementById('dynUseVerlet')?.closest('.inline-pair');
                if (verletRow) verletRow.style.display = useXPBD ? 'none' : '';
                if (verletChk) verletChk.style.display = useXPBD ? 'none' : '';
            }
            updateVerletVisibility();
            const edgeModeEl = document.getElementById('dynUseEdgeMode');
            if (edgeModeEl) edgeModeEl.addEventListener('change', updateVerletVisibility);

            function scheduleAutoRecompute(){
                if (autoTimeout) { clearTimeout(autoTimeout); autoTimeout = null; }
                autoTimeout = setTimeout(()=>{
                    const btn = document.getElementById('computeEdgeScoresBtn');
                    if (btn) btn.click();
                }, 275);
            }

            function animate() {
                const now = performance.now();
                const delta = now - lastFrameTime;
                lastFrameTime = now;

                if (now - lastFPSUpdate > 500) { // Update FPS twice a second
                    const fps = 1000 / delta;
                    const statsPerf = document.getElementById('statsPerf');
                    if (statsPerf) statsPerf.textContent = `FPS: ${fps.toFixed(1)}`;
                    lastFPSUpdate = now;
                }

                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }).catch(err => {
            console.error('Failed to load module:', err);
            setStatus('Failed to load module', false);
        });
    </script>
</body>
</html> 